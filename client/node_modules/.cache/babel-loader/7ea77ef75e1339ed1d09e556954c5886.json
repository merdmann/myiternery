{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"react\"), require(\"styled-components\"));else if (typeof define === 'function' && define.amd) define(\"atomicLayout\", [\"react\", \"styled-components\"], factory);else if (typeof exports === 'object') exports[\"atomicLayout\"] = factory(require(\"react\"), require(\"styled-components\"));else root[\"atomicLayout\"] = factory(root[\"react\"], root[\"styled-components\"]);\n})(typeof self !== 'undefined' ? self : this, function (__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 2);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE__0__;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports) {\n      module.exports = __WEBPACK_EXTERNAL_MODULE__1__;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, __webpack_exports__, __webpack_require__) {\n      \"use strict\";\n\n      __webpack_require__.r(__webpack_exports__); // CONCATENATED MODULE: ./src/const/defaultOptions.ts\n\n\n      var defaultOptions = {\n        defaultUnit: 'px',\n        defaultBehavior: 'up',\n        defaultBreakpointName: 'xs',\n        breakpoints: {\n          xs: {\n            maxWidth: '575px'\n          },\n          sm: {\n            minWidth: '576px',\n            maxWidth: '768px'\n          },\n          md: {\n            minWidth: '769px',\n            maxWidth: '992px'\n          },\n          lg: {\n            minWidth: '993px',\n            maxWidth: '1199px'\n          },\n          xl: {\n            minWidth: '1200px'\n          }\n        }\n      };\n      /* harmony default export */\n\n      var const_defaultOptions = defaultOptions; // CONCATENATED MODULE: ./src/utils/invariant/invariant.ts\n\n      function invariant(variable, message) {\n        if (!variable) {\n          throw new Error(message);\n        }\n      } // CONCATENATED MODULE: ./src/utils/invariant/index.ts\n      // CONCATENATED MODULE: ./src/utils/functions/warn/warn.ts\n\n\n      function warn(predicate, message) {\n        if (!predicate) {\n          console.warn(message);\n        }\n      } // CONCATENATED MODULE: ./src/utils/functions/warn/index.ts\n      // CONCATENATED MODULE: ./src/Layout.ts\n\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      var Layout_Layout =\n      /*#__PURE__*/\n      function () {\n        function Layout(options) {\n          _classCallCheck(this, Layout);\n\n          _defineProperty(this, \"defaultUnit\", const_defaultOptions.defaultUnit);\n\n          _defineProperty(this, \"defaultBehavior\", const_defaultOptions.defaultBehavior);\n\n          _defineProperty(this, \"breakpoints\", const_defaultOptions.breakpoints);\n\n          _defineProperty(this, \"defaultBreakpointName\", const_defaultOptions.defaultBreakpointName);\n\n          _defineProperty(this, \"isConfigureCalled\", false);\n\n          return options ? this.configure(options, false) : this;\n        }\n        /**\n         * Applies global layout options.\n         */\n\n\n        _createClass(Layout, [{\n          key: \"configure\",\n          value: function configure(options) {\n            var _this = this;\n\n            var warnOnMultiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            if (warnOnMultiple) {\n              warn(!this.isConfigureCalled, 'Failed to configure Layout: do not call `Layout.configure()` more than once. Layout configuration must remain consistent throughout the application.');\n            }\n\n            invariant(options && _typeof(options) === 'object', \"Failed to configure Layout: expected an options Object, but got: \".concat(options, \".\"));\n            Object.keys(options || {}).forEach(function (optionName) {\n              _this[optionName] = options[optionName];\n            });\n            invariant(this.breakpoints, 'Failed to configure Layout: expected to have at least one breakpoint specified, but got none.');\n            invariant(this.breakpoints.hasOwnProperty(this.defaultBreakpointName), \"Failed to configure Layout: cannot use \\\"\".concat(this.defaultBreakpointName, \"\\\" as the default breakpoint (breakpoint not found).\"));\n            invariant(this.defaultBreakpointName, \"Failed to configure Layout: expected \\\"defaultBreakpointName\\\" property set, but got: \".concat(this.defaultBreakpointName, \".\")); // invariant(\n            //   typeof this.defaultBreakpointName === 'string',\n            //   `Failed to configure Layout: expected \"defaultBreakpointName\" to be a string, but got: ${typeof this\n            //     .defaultBreakpointName}`,\n            // )\n            // Mark configure method as called to prevent its multiple calls\n\n            this.isConfigureCalled = warnOnMultiple;\n            return this;\n          }\n          /**\n           * Returns the collection of breakpoint names present\n           * in the current layout configuration.\n           */\n\n        }, {\n          key: \"getBreakpointNames\",\n          value: function getBreakpointNames() {\n            return Object.keys(this.breakpoints);\n          }\n          /**\n           * Returns breakpoint options by the given breakpoint name.\n           */\n\n        }, {\n          key: \"getBreakpoint\",\n          value: function getBreakpoint(breakpointName) {\n            return this.breakpoints[breakpointName];\n          }\n        }]);\n\n        return Layout;\n      }();\n      /* harmony default export */\n\n\n      var src_Layout = new Layout_Layout(); // EXTERNAL MODULE: external \"styled-components\"\n\n      var external_styled_components_ = __webpack_require__(1);\n\n      var external_styled_components_default =\n      /*#__PURE__*/\n      __webpack_require__.n(external_styled_components_); // CONCATENATED MODULE: ./src/utils/functions/compose/compose.ts\n\n      /**\n       * Returns a functional composition of the given functions.\n       * Applies no currying.\n       */\n\n\n      function compose() {\n        for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n          funcs[_key] = arguments[_key];\n        }\n\n        return funcs.reduce(function (f, g) {\n          return function () {\n            return f(g.apply(void 0, arguments));\n          };\n        });\n      } // CONCATENATED MODULE: ./src/utils/functions/compose/index.ts\n      // CONCATENATED MODULE: ./src/utils/functions/isset/isset.ts\n\n\n      function isset(variable) {\n        return typeof variable !== 'undefined' && variable !== null;\n      } // CONCATENATED MODULE: ./src/utils/functions/isset/index.ts\n      // CONCATENATED MODULE: ./src/utils/math/transformNumeric.ts\n\n\n      function transformNumeric(value) {\n        if (!isset(value)) {\n          return '';\n        }\n        /**\n         * Suffix numeric value with the default unit.\n         * Accept explicit (string) value as-is.\n         *\n         * When given value is zero then its generated as it is, no suffix is attached\n         */\n\n\n        var suffix = typeof value === 'number' && value !== 0 ? src_Layout.defaultUnit : '';\n        return \"\".concat(value).concat(suffix);\n      } // CONCATENATED MODULE: ./src/utils/strings/sanitizeTemplateArea/sanitizeTemplateArea.ts\n\n      /**\n       * Trims whitespace, removes duplicate single quotes and enforces\n       * that area line is wrapped in single quotes.\n       */\n\n\n      var sanitizeTemplateArea = compose(function (area) {\n        return area.replace(/^.+$/gm, function (areaName) {\n          return \"'\".concat(areaName, \"'\");\n        });\n      }, function (area) {\n        return area.replace(/'+/gm, '');\n      }, function (area) {\n        return area.trim();\n      });\n      /* harmony default export */\n\n      var sanitizeTemplateArea_sanitizeTemplateArea = sanitizeTemplateArea; // CONCATENATED MODULE: ./src/utils/strings/sanitizeTemplateArea/index.ts\n      // CONCATENATED MODULE: ./src/const/propAliases.ts\n\n      var transformTemplateString = compose(function (areas) {\n        return areas.join('\\n');\n      }, function (areas) {\n        return areas.map(sanitizeTemplateArea_sanitizeTemplateArea);\n      }, function (template) {\n        return template.split('\\n');\n      }, function (template) {\n        return template.trim();\n      });\n      /**\n       * Collection of prop aliases.\n       * Prop alias is a prop name accepted by a component which is later\n       * substituted by one or multiple CSS properties with a single value.\n       * Each prop value can have a value transformer.\n       */\n\n      var propAliases = {\n        /* CSS Grid */\n        area: {\n          props: ['grid-area']\n        },\n        areas: {\n          props: ['grid-template-areas'],\n          transformValue: transformTemplateString\n        },\n        template: {\n          props: ['grid-template-areas'],\n          transformValue: transformTemplateString\n        },\n        templateCols: {\n          props: ['grid-template-columns']\n        },\n        templateRows: {\n          props: ['grid-template-rows']\n        },\n        col: {\n          props: ['grid-column']\n        },\n        colStart: {\n          props: ['grid-column-start']\n        },\n        colEnd: {\n          props: ['grid-column-end']\n        },\n        row: {\n          props: ['grid-row']\n        },\n        rowStart: {\n          props: ['grid-row-start']\n        },\n        rowEnd: {\n          props: ['grid-row-end']\n        },\n        gap: {\n          props: ['grid-gap'],\n          transformValue: transformNumeric\n        },\n        gapCol: {\n          props: ['grid-column-gap'],\n          transformValue: transformNumeric\n        },\n        gapRow: {\n          props: ['grid-row-gap'],\n          transformValue: transformNumeric\n        },\n        gutter: {\n          props: ['grid-gap'],\n          transformValue: transformNumeric\n        },\n        gutterCol: {\n          props: ['grid-column-gap'],\n          transformValue: transformNumeric\n        },\n        gutterRow: {\n          props: ['grid-row-gap'],\n          transformValue: transformNumeric\n        },\n        autoRows: {\n          props: ['grid-auto-rows'],\n          transformValue: transformNumeric\n        },\n        autoCols: {\n          props: ['grid-auto-columns'],\n          transformValue: transformNumeric\n        },\n        autoFlow: {\n          props: ['grid-auto-flow']\n        },\n        align: {\n          props: ['align-self']\n        },\n        alignItems: {\n          props: ['align-items']\n        },\n        justify: {\n          props: ['justify-self']\n        },\n        justifyItems: {\n          props: ['justify-items']\n        },\n        justifyContent: {\n          props: ['justify-content']\n        },\n        place: {\n          props: ['place-self']\n        },\n        placeItems: {\n          props: ['place-items']\n        },\n        placeContent: {\n          props: ['place-content']\n        },\n\n        /* CSS Flexbox */\n        flexDirection: {\n          props: ['flex-direction']\n        },\n        flexShrink: {\n          props: ['flex-shrink']\n        },\n        flexGrow: {\n          props: ['flex-grow']\n        },\n        flexWrap: {\n          props: ['flex-wrap']\n        },\n\n        /* Dimensions */\n        height: {\n          props: ['height'],\n          transformValue: transformNumeric\n        },\n        minHeight: {\n          props: ['min-height'],\n          transformValue: transformNumeric\n        },\n        maxHeight: {\n          props: ['max-height'],\n          transformValue: transformNumeric\n        },\n        width: {\n          props: ['width'],\n          transformValue: transformNumeric\n        },\n        minWidth: {\n          props: ['min-width'],\n          transformValue: transformNumeric\n        },\n        maxWidth: {\n          props: ['max-width'],\n          transformValue: transformNumeric\n        },\n\n        /* Space */\n        margin: {\n          props: ['margin'],\n          transformValue: transformNumeric\n        },\n        marginTop: {\n          props: ['margin-top'],\n          transformValue: transformNumeric\n        },\n        marginRight: {\n          props: ['margin-right'],\n          transformValue: transformNumeric\n        },\n        marginBottom: {\n          props: ['margin-bottom'],\n          transformValue: transformNumeric\n        },\n        marginLeft: {\n          props: ['margin-left'],\n          transformValue: transformNumeric\n        },\n        marginVertical: {\n          props: ['margin-top', 'margin-bottom'],\n          transformValue: transformNumeric\n        },\n        marginHorizontal: {\n          props: ['margin-right', 'margin-left'],\n          transformValue: transformNumeric\n        },\n        padding: {\n          props: ['padding'],\n          transformValue: transformNumeric\n        },\n        paddingTop: {\n          props: ['padding-top'],\n          transformValue: transformNumeric\n        },\n        paddingRight: {\n          props: ['padding-right'],\n          transformValue: transformNumeric\n        },\n        paddingBottom: {\n          props: ['padding-bottom'],\n          transformValue: transformNumeric\n        },\n        paddingLeft: {\n          props: ['padding-left'],\n          transformValue: transformNumeric\n        },\n        paddingVertical: {\n          props: ['padding-top', 'padding-bottom'],\n          transformValue: transformNumeric\n        },\n        paddingHorizontal: {\n          props: ['padding-right', 'padding-left'],\n          transformValue: transformNumeric\n        }\n      };\n      /* harmony default export */\n\n      var const_propAliases = propAliases; // CONCATENATED MODULE: ./src/utils/strings/toLowerCaseFirst/toLowerCaseFirst.ts\n\n      function toLowerCaseFirst(str) {\n        return str.slice(0, 1).toLowerCase() + str.slice(1, str.length);\n      } // CONCATENATED MODULE: ./src/utils/strings/toLowerCaseFirst/index.ts\n      // CONCATENATED MODULE: ./src/utils/strings/parsePropName/parsePropName.ts\n\n      /**\n       * Returns a parsed prop summary, which includes pure prop name,\n       * an optional breakpoint name and breakpoint behavior.\n       *\n       * \\w+(?<=(sm)?(only)?)$\n       * This RegExp also works well. May consider implementing once\n       * lookbehind is supported everywhere.\n       */\n\n\n      function parsePropName(originPropName) {\n        var joinedBreakpointNames = src_Layout.getBreakpointNames().join('|');\n        var joinedBehaviors = ['down', 'only'].join('|');\n        var breakpointExp = new RegExp(\"(\".concat(joinedBreakpointNames, \")$\"), 'gi');\n        var behaviorExp = new RegExp(\"(\".concat(joinedBehaviors, \")$\"), 'gi');\n        var behaviorMatch = originPropName.match(behaviorExp);\n        var behavior = behaviorMatch ? behaviorMatch[0] : '';\n        var breakpointMatch = originPropName.replace(behavior, '').match(breakpointExp);\n        var breakpointName = breakpointMatch ? breakpointMatch[0] : '';\n        var purePropName = originPropName.replace(breakpointName, '').replace(behavior, '');\n        /**\n         * Get normalized breakpoint name.\n         * When a breakpoint name is a part of the prop name, covert it first letter\n         * to lowercase to match the layout options. Otherwise, take the default\n         * breakpoint name.\n         */\n\n        var normalizedBreakpointName = breakpointName ? toLowerCaseFirst(breakpointName) : src_Layout.defaultBreakpointName;\n        var isDefaultBreakpoint = normalizedBreakpointName === src_Layout.defaultBreakpointName;\n        return {\n          originPropName: originPropName,\n          purePropName: purePropName,\n          behavior: behavior ? toLowerCaseFirst(behavior) : src_Layout.defaultBehavior,\n          breakpoint: {\n            name: normalizedBreakpointName,\n            isDefault: isDefaultBreakpoint\n          }\n        };\n      } // CONCATENATED MODULE: ./src/utils/strings/parsePropName/index.ts\n      // CONCATENATED MODULE: ./src/utils/strings/toDashedString/toDashedString.ts\n\n      /**\n       * @example\n       * toDashedString('fooBar') // \"foo-bar\"\n       */\n\n\n      function toDashedString(str) {\n        return str.replace(/[A-Z]/g, function (capitalLetter) {\n          return \"-\".concat(capitalLetter).toLowerCase();\n        });\n      } // CONCATENATED MODULE: ./src/utils/strings/toDashedString/index.ts\n      // CONCATENATED MODULE: ./src/utils/styles/normalizeQuery/normalizeQuery.ts\n\n\n      function _slicedToArray(arr, i) {\n        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n      }\n\n      function _nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      function _iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function _arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n      /**\n       * Normalizes given media query object to a list of [propName, propValue].\n       * @example\n       * normalizeQuery({ minWidth: 120 })\n       * // [['min-width', 120]]\n       */\n\n\n      function normalizeQuery(queryProps) {\n        return Object.entries(queryProps).filter(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              _ = _ref2[0],\n              propValue = _ref2[1];\n\n          return isset(propValue);\n        }).map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              propName = _ref4[0],\n              propValue = _ref4[1];\n\n          return [toDashedString(propName), propValue];\n        });\n      } // CONCATENATED MODULE: ./src/utils/styles/normalizeQuery/index.ts\n      // CONCATENATED MODULE: ./src/utils/styles/createMediaQuery/createMediaQuery.ts\n\n\n      function createMediaQuery_slicedToArray(arr, i) {\n        return createMediaQuery_arrayWithHoles(arr) || createMediaQuery_iterableToArrayLimit(arr, i) || createMediaQuery_nonIterableRest();\n      }\n\n      function createMediaQuery_nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      function createMediaQuery_iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function createMediaQuery_arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n      /**\n       * Determines whether a given media query param should be added\n       * to the media query string based on a breakpoint's behavior.\n       */\n\n\n      var shouldAppendProperty = function shouldAppendProperty(queryParam, behavior) {\n        var _queryParam$split = queryParam.split('-'),\n            _queryParam$split2 = createMediaQuery_slicedToArray(_queryParam$split, 2),\n            prefix = _queryParam$split2[0],\n            splitPropName = _queryParam$split2[1];\n\n        var isDimensionalProp = ['height', 'width'].includes(splitPropName);\n\n        if (!isDimensionalProp) {\n          return true;\n        }\n\n        return prefix === 'min' && ['up', 'only'].includes(behavior) || prefix === 'max' && ['down', 'only'].includes(behavior);\n      };\n\n      var filterRelevantQueryParams = function filterRelevantQueryParams(behavior) {\n        return function (queryList) {\n          return queryList.filter(function (_ref) {\n            var _ref2 = createMediaQuery_slicedToArray(_ref, 1),\n                queryParam = _ref2[0];\n\n            return shouldAppendProperty(queryParam, behavior);\n          });\n        };\n      };\n      /**\n       * Joins a given query params list with the given transformer function.\n       */\n\n\n      var joinQueryList = function joinQueryList(transformer) {\n        return function (queryList) {\n          return queryList.map(transformer).join(' and ');\n        };\n      };\n\n      function createMediaQuery_createMediaQuery(breakpoint, behavior) {\n        return compose(joinQueryList(function (_ref3) {\n          var _ref4 = createMediaQuery_slicedToArray(_ref3, 2),\n              dashedQueryProp = _ref4[0],\n              propValue = _ref4[1];\n\n          return \"(\".concat(dashedQueryProp, \":\").concat(String(transformNumeric(propValue)), \")\");\n        }), filterRelevantQueryParams(behavior), normalizeQuery)(breakpoint);\n      } // CONCATENATED MODULE: ./src/utils/styles/createMediaQuery/index.ts\n      // CONCATENATED MODULE: ./src/utils/styles/applyStyles/applyStyles.ts\n\n\n      var applyStyles_createStyleString = function createStyleString(propsList, propValue, breakpoint, behavior) {\n        var styleProps = propsList.map(function (propName) {\n          return \"\".concat(propName, \":\").concat(String(propValue), \";\");\n        }).join('');\n        var breakpointOptions = src_Layout.getBreakpoint(breakpoint.name);\n        /**\n         * Wrap CSS rule in a media query only if its prop includes\n         * a breakpoint and behavior different than the default ones.\n         */\n\n        var shouldWrapInMediaQuery = breakpointOptions && !(breakpoint.isDefault && behavior === src_Layout.defaultBehavior);\n        return shouldWrapInMediaQuery ? \"@media \".concat(createMediaQuery_createMediaQuery(breakpointOptions, behavior), \" {\").concat(styleProps, \"}\") : styleProps;\n      };\n\n      function applyStyles(pristineProps) {\n        return Object.keys(pristineProps)\n        /* Parse each prop to include \"breakpoint\" and \"behavior\" */\n        .map(parsePropName)\n        /* Filter out props that are not included in prop aliases */\n        .filter(function (_ref) {\n          var purePropName = _ref.purePropName;\n          return const_propAliases.hasOwnProperty(purePropName);\n        })\n        /* Filter out props with \"undefined\" or \"null\" as value */\n        .filter(function (_ref2) {\n          var originPropName = _ref2.originPropName;\n          return isset(pristineProps[originPropName]);\n        })\n        /* Map each prop to a CSS string */\n        .map(function (_ref3) {\n          var purePropName = _ref3.purePropName,\n              originPropName = _ref3.originPropName,\n              breakpoint = _ref3.breakpoint,\n              behavior = _ref3.behavior;\n          var _propAliases$pureProp = const_propAliases[purePropName],\n              props = _propAliases$pureProp.props,\n              transformValue = _propAliases$pureProp.transformValue;\n          var propValue = pristineProps[originPropName];\n          var transformedPropValue = transformValue ? transformValue(propValue) : propValue;\n          return applyStyles_createStyleString(props, transformedPropValue, breakpoint, behavior);\n        }).join(' ');\n      } // CONCATENATED MODULE: ./src/utils/styles/applyStyles/index.ts\n      // CONCATENATED MODULE: ./src/components/Box.tsx\n\n\n      function _templateObject() {\n        var data = _taggedTemplateLiteral([\"\\n  && {\\n    \", \";\\n    display: \", \";\\n  }\\n\"]);\n\n        _templateObject = function _templateObject() {\n          return data;\n        };\n\n        return data;\n      }\n\n      function _taggedTemplateLiteral(strings, raw) {\n        if (!raw) {\n          raw = strings.slice(0);\n        }\n\n        return Object.freeze(Object.defineProperties(strings, {\n          raw: {\n            value: Object.freeze(raw)\n          }\n        }));\n      }\n\n      var Box = external_styled_components_default.a.div(_templateObject(), applyStyles, function (_ref) {\n        var flex = _ref.flex,\n            inline = _ref.inline;\n        return flex ? inline ? 'inline-flex' : 'flex' : inline ? 'inline-block' : 'block';\n      });\n      /* harmony default export */\n\n      var components_Box = Box; // EXTERNAL MODULE: external \"react\"\n\n      var external_react_ = __webpack_require__(0); // CONCATENATED MODULE: ./src/utils/functions/memoizeWith/memoizeWith.ts\n\n\n      function memoizeWith(mappingFunc) {\n        var cache = {};\n        return function (func) {\n          return function () {\n            var key = mappingFunc.apply(void 0, arguments);\n\n            if (!(key in cache)) {\n              cache[key] = func.apply(void 0, arguments);\n            }\n\n            return cache[key];\n          };\n        };\n      } // CONCATENATED MODULE: ./src/utils/functions/memoizeWith/index.ts\n      // CONCATENATED MODULE: ./src/utils/templates/getAreasList/getAreasList.ts\n\n\n      function getAreasList_slicedToArray(arr, i) {\n        return getAreasList_arrayWithHoles(arr) || getAreasList_iterableToArrayLimit(arr, i) || getAreasList_nonIterableRest();\n      }\n\n      function getAreasList_nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      function getAreasList_iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function getAreasList_arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n\n      function getAreasList(templateProps) {\n        var areasList = Object.entries(templateProps).reduce(function (acc, _ref) {\n          var _ref2 = getAreasList_slicedToArray(_ref, 2),\n              templateName = _ref2[0],\n              templateAreas = _ref2[1];\n\n          var _parsePropName = parsePropName(templateName),\n              breakpoint = _parsePropName.breakpoint,\n              behavior = _parsePropName.behavior;\n\n          var nextAreas = acc.areas.concat(templateAreas);\n          var nextTemplates = acc.templates.concat({\n            breakpoint: src_Layout.getBreakpoint(breakpoint.name),\n            behavior: behavior,\n            areas: templateAreas\n          });\n          return {\n            areas: nextAreas,\n            templates: nextTemplates\n          };\n        }, {\n          areas: [],\n          templates: []\n        });\n        var areas = areasList.areas,\n            templates = areasList.templates;\n        return {\n          areas: Array.from(new Set(areas)),\n          templates: templates\n        };\n      } // CONCATENATED MODULE: ./src/utils/templates/getAreasList/index.ts\n      // CONCATENATED MODULE: ./src/utils/strings/hashString/hashString.ts\n\n\n      function hashString(str) {\n        var length = str.length;\n        var hash = 0;\n        var i = 0;\n\n        if (length > 0) {\n          while (i < length) {\n            hash = (hash << 5) - hash + str.charCodeAt(i++) | 0;\n          }\n        }\n\n        return hash;\n      } // CONCATENATED MODULE: ./src/utils/strings/hashString/index.ts\n      // CONCATENATED MODULE: ./src/components/MediaQuery.tsx\n\n\n      function _objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n\n        var target = _objectWithoutPropertiesLoose(source, excluded);\n\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n          for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n      function _objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n          key = sourceKeys[i];\n          if (excluded.indexOf(key) >= 0) continue;\n          target[key] = source[key];\n        }\n\n        return target;\n      }\n\n      function MediaQuery_slicedToArray(arr, i) {\n        return MediaQuery_arrayWithHoles(arr) || MediaQuery_iterableToArrayLimit(arr, i) || MediaQuery_nonIterableRest();\n      }\n\n      function MediaQuery_nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      function MediaQuery_iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function MediaQuery_arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n\n      var MediaQuery_createMediaQuery = function createMediaQuery(queryParams) {\n        return compose(joinQueryList(function (_ref) {\n          var _ref2 = MediaQuery_slicedToArray(_ref, 2),\n              paramName = _ref2[0],\n              paramValue = _ref2[1];\n          /**\n           * Transform values that begin with a number to prevent\n           * transformations of \"calc\" expressions.\n           * Transformation of numerics is necessary when a simple\n           * number is used as a value (min-width: 750) is not valid.\n           *\n           * (min-width: 750) ==> (min-width: 750px)\n           */\n\n\n          var resolvedParamValue = /^\\d/.test(String(paramValue)) ? transformNumeric(paramValue) : paramValue;\n          return \"(\".concat(paramName, \":\").concat(resolvedParamValue, \")\");\n        }), normalizeQuery)(queryParams);\n      };\n\n      var MediaQuery_MediaQuery = function MediaQuery(props) {\n        var children = props.children,\n            queryParams = _objectWithoutProperties(props, [\"children\"]);\n\n        var query = external_react_[\"useMemo\"](function () {\n          return MediaQuery_createMediaQuery(queryParams);\n        }, [queryParams]);\n\n        var _React$useState = external_react_[\"useState\"](false),\n            _React$useState2 = MediaQuery_slicedToArray(_React$useState, 2),\n            matches = _React$useState2[0],\n            setMatches = _React$useState2[1];\n\n        var handleMediaQueryChange = function handleMediaQueryChange(mediaQueryList) {\n          setMatches(mediaQueryList.matches);\n        };\n\n        external_react_[\"useEffect\"](function () {\n          var mediaQueryList = matchMedia(query);\n          handleMediaQueryChange(mediaQueryList);\n          mediaQueryList.addListener(handleMediaQueryChange);\n          return function () {\n            return mediaQueryList.removeListener(handleMediaQueryChange);\n          };\n        }, Object.keys(queryParams));\n        return children(matches);\n      };\n      /* harmony default export */\n\n\n      var components_MediaQuery = MediaQuery_MediaQuery; // CONCATENATED MODULE: ./src/utils/strings/capitalize/capitalize.ts\n\n      function capitalize(str) {\n        return str.replace(/^./, function (firstLetter) {\n          return firstLetter.toUpperCase();\n        });\n      } // CONCATENATED MODULE: ./src/utils/strings/capitalize/index.ts\n      // CONCATENATED MODULE: ./src/utils/functions/pop/pop.ts\n\n      /**\n       * Returns the shallow copy of the given array with\n       * the last element removed.\n       */\n\n\n      function pop(list) {\n        return list.slice(0, list.length - 1);\n      } // CONCATENATED MODULE: ./src/utils/functions/pop/index.ts\n      // CONCATENATED MODULE: ./src/utils/functions/when/when.ts\n\n\n      function when(predicate, whenTrueFunc) {\n        return function (args) {\n          return predicate(args) ? whenTrueFunc(args) : args;\n        };\n      } // CONCATENATED MODULE: ./src/utils/functions/when/index.ts\n      // CONCATENATED MODULE: ./src/utils/functions/spread/spread.ts\n\n\n      function spread(func) {\n        return function (args) {\n          return func.apply(null, args);\n        };\n      } // CONCATENATED MODULE: ./src/utils/functions/spread/index.ts\n      // CONCATENATED MODULE: ./src/utils/strings/getPrefix/getPrefix.ts\n\n\n      function getPrefix(str) {\n        var prompt = str.match(/^(min|max)/);\n        return prompt ? prompt[0] : '';\n      } // CONCATENATED MODULE: ./src/utils/strings/getPrefix/index.ts\n      // CONCATENATED MODULE: ./src/utils/breakpoints/mergeBreakpoints/mergeBreakpoints.ts\n\n\n      function _objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            mergeBreakpoints_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function mergeBreakpoints_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n      /**\n       * Merges two given mergable breakpoints.\n       */\n\n\n      function mergeBreakpoints(breakpointA, breakpointB, includesArea) {\n        var prevBehavior = breakpointB.behavior;\n        var nextBehavior = breakpointA.behavior;\n        var wentUp = prevBehavior === 'up';\n        var goesDown = nextBehavior === 'down';\n        var behavesSame = prevBehavior === nextBehavior;\n        var behavesInclusive = wentUp && goesDown;\n        var shouldStretch = wentUp;\n\n        var mergedBreakpoint = _objectSpread({}, breakpointB, breakpointA);\n\n        return Object.keys(mergedBreakpoint).reduce(function (acc, propName) {\n          var nextValue = mergedBreakpoint[propName];\n          var prefix = getPrefix(propName);\n\n          if (propName === 'behavior') {\n            if (!includesArea && shouldStretch) {\n              nextValue = 'down';\n            }\n          }\n\n          if (prefix === 'max') {\n            if (!includesArea && shouldStretch) {\n              var mirrorValue = breakpointA[propName.replace(/^max/, 'min')];\n              nextValue = \"calc(\".concat(transformNumeric(mirrorValue), \" - 1px)\");\n            }\n          }\n\n          if (prefix === 'min') {\n            if (includesArea) {\n              if (behavesSame || behavesInclusive) {\n                nextValue = breakpointB[propName];\n              }\n            } else {\n              if (shouldStretch) {\n                nextValue = breakpointB[propName];\n              }\n            }\n          }\n\n          return _objectSpread({}, acc, mergeBreakpoints_defineProperty({}, propName, nextValue));\n        }, {\n          behavior: const_defaultOptions.defaultBehavior\n        });\n      } // CONCATENATED MODULE: ./src/utils/breakpoints/mergeBreakpoints/index.ts\n      // CONCATENATED MODULE: ./src/utils/breakpoints/openBreakpoint/openBreakpoint.ts\n\n\n      function openBreakpoint_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            openBreakpoint_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function openBreakpoint_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n      /**\n       * Opens the given breakpoint.\n       * A breakpoint is considered open when it has no upper boundary. For example,\n       * a breakpoint that has \"maxWidth: undefined\" is the open breakpoint.\n       */\n\n\n      function openBreakpoint(breakpoint) {\n        return Object.keys(breakpoint).reduce(function (acc, key) {\n          return openBreakpoint_objectSpread({}, acc, openBreakpoint_defineProperty({}, key, getPrefix(key) === 'max' ? undefined : breakpoint[key]));\n        }, {});\n      } // CONCATENATED MODULE: ./src/utils/breakpoints/openBreakpoint/index.ts\n      // CONCATENATED MODULE: ./src/utils/breakpoints/shouldMergeBreakpoints/shouldMergeBreakpoints.ts\n\n      /**\n       * Replaces the prefixes in a parameter name.\n       * Allows strict comparison of same parameters with different prefixes.\n       * Does not test for inclusion/notch.\n       *\n       * @example\n       * neutralizeParamName('maxWidth') // \"_width\"\n       * neutralizeParamName('minWidth') // \"_width\"\n       */\n\n\n      var neutralizeParamName = function neutralizeParamName(paramName) {\n        return paramName.replace(/^min|max/, '_');\n      };\n      /**\n       * Determines whether two given breakpoints can be merged.\n       * Assures non-compatible breakpoints are not prompted to\n       * be merged during the area params composition.\n       */\n\n\n      function shouldCombineBreakpoints(breakpointA, breakpointB) {\n        var allParams = Object.keys(breakpointA).concat(Object.keys(breakpointB));\n        return allParams.every(function (pristineParamName, index) {\n          var paramName = neutralizeParamName(pristineParamName);\n          var prevParamName = neutralizeParamName(allParams[index - 1] || paramName);\n          return paramName === prevParamName;\n        });\n      } // CONCATENATED MODULE: ./src/utils/breakpoints/shouldMergeBreakpoints/index.ts\n      // CONCATENATED MODULE: ./src/utils/breakpoints/getAreaBreakpoints/getAreaBreakpoints.ts\n\n\n      function getAreaBreakpoints_slicedToArray(arr, i) {\n        return getAreaBreakpoints_arrayWithHoles(arr) || getAreaBreakpoints_iterableToArrayLimit(arr, i) || getAreaBreakpoints_nonIterableRest();\n      }\n\n      function getAreaBreakpoints_iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function getAreaBreakpoints_objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n        var target = getAreaBreakpoints_objectWithoutPropertiesLoose(source, excluded);\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n          for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n      function getAreaBreakpoints_objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n          key = sourceKeys[i];\n          if (excluded.indexOf(key) >= 0) continue;\n          target[key] = source[key];\n        }\n\n        return target;\n      }\n\n      function getAreaBreakpoints_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            getAreaBreakpoints_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function getAreaBreakpoints_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function _toConsumableArray(arr) {\n        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n      }\n\n      function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n      }\n\n      function _arrayWithoutHoles(arr) {\n        if (Array.isArray(arr)) {\n          for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n            arr2[i] = arr[i];\n          }\n\n          return arr2;\n        }\n      }\n\n      function _toArray(arr) {\n        return getAreaBreakpoints_arrayWithHoles(arr) || _iterableToArray(arr) || getAreaBreakpoints_nonIterableRest();\n      }\n\n      function getAreaBreakpoints_nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      function _iterableToArray(iter) {\n        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n      }\n\n      function getAreaBreakpoints_arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n\n      var updateWith = function updateWith(key, updateFunc) {\n        return function (args) {\n          var _args = _toArray(args),\n              first = _args[0],\n              rest = _args.slice(1);\n\n          return [updateFunc(args)].concat(_toConsumableArray(rest));\n        };\n      };\n\n      var getAreaBreakpoints_createContext = function createContext(areaName) {\n        return function (areaBreakpointsList, template, index, templates) {\n          var isLastTemplate = index === templates.length - 1;\n          var areas = template.areas,\n              behavior = template.behavior,\n              breakpoint = template.breakpoint;\n          var includesArea = areas.includes(areaName);\n          var prevAreaBreakpoint = areaBreakpointsList[areaBreakpointsList.length - 1];\n          var nextAreaBreakpoint = getAreaBreakpoints_objectSpread({}, breakpoint, {\n            behavior: behavior\n          });\n\n          var _ref = prevAreaBreakpoint || {\n            behavior: ''\n          },\n              prevBehavior = _ref.behavior,\n              prevBreakpoint = getAreaBreakpoints_objectWithoutProperties(_ref, [\"behavior\"]);\n\n          var shouldMerge = Boolean(prevAreaBreakpoint) && shouldCombineBreakpoints(prevBreakpoint, breakpoint);\n          return [nextAreaBreakpoint, prevAreaBreakpoint, includesArea, isLastTemplate, shouldMerge, areaBreakpointsList];\n        };\n      };\n\n      var canMergeBreakpoints = function canMergeBreakpoints(_ref2) {\n        var _ref3 = getAreaBreakpoints_slicedToArray(_ref2, 5),\n            nextAreaBreakpoint = _ref3[0],\n            prevAreaBreakpoint = _ref3[1],\n            includesArea = _ref3[2],\n            isLastTemplate = _ref3[3],\n            shouldMerge = _ref3[4];\n\n        return shouldMerge;\n      };\n\n      var shouldOpenBreakpoint = function shouldOpenBreakpoint(_ref4) {\n        var _ref5 = getAreaBreakpoints_slicedToArray(_ref4, 4),\n            nextAreaBreakpoint = _ref5[0],\n            prevAreaBreakpoint = _ref5[1],\n            includesArea = _ref5[2],\n            isLastTemplate = _ref5[3];\n\n        return isLastTemplate && nextAreaBreakpoint.behavior === 'up';\n      };\n\n      var getAreaBreakpoints_updateBreakpointsList = function updateBreakpointsList(_ref6) {\n        var _ref7 = getAreaBreakpoints_slicedToArray(_ref6, 6),\n            nextAreaBreakpoint = _ref7[0],\n            prevAreaBreakpoint = _ref7[1],\n            includesArea = _ref7[2],\n            isLastTemplate = _ref7[3],\n            shouldMerge = _ref7[4],\n            areaBreakpointsList = _ref7[5];\n        /* Fallback to an empty object when there is no previous breakpoint in the list */\n\n\n        var _ref8 = prevAreaBreakpoint || {\n          behavior: ''\n        },\n            prevBehavior = _ref8.behavior;\n\n        var nextBehavior = nextAreaBreakpoint.behavior;\n        var wentUp = prevBehavior === 'up';\n        var goesDown = nextBehavior === 'down';\n        var behavesSame = prevBehavior === nextBehavior;\n        var behavesInclusive = wentUp && goesDown;\n        /* Alias for better readability */\n\n        var shouldStretch = wentUp;\n        var shouldReplaceLastArea = includesArea && (behavesSame || behavesInclusive);\n\n        if (!shouldMerge) {\n          shouldReplaceLastArea = false;\n        }\n\n        var newBreakpoint = [nextAreaBreakpoint];\n\n        if (!includesArea) {\n          /**\n           * When the area is stretched, append explicit \"null\" afterward\n           * to prevent the stretched area from being treated as a sibling area\n           * in any further calculations.\n           */\n          newBreakpoint = shouldStretch ? [nextAreaBreakpoint, null] : [null];\n\n          if (shouldStretch) {\n            shouldReplaceLastArea = true;\n          }\n        }\n\n        var targetList = shouldReplaceLastArea ? pop(areaBreakpointsList) : areaBreakpointsList;\n        return targetList.concat(newBreakpoint);\n      };\n\n      var getAreaBreakpoints_getAreaBreakpoints = function getAreaBreakpoints(areaName, templates) {\n        return templates.reduce(compose(getAreaBreakpoints_updateBreakpointsList, when(shouldOpenBreakpoint, updateWith('nextAreaBreakpoint', spread(openBreakpoint))), when(canMergeBreakpoints, updateWith('nextAreaBreakpoint', spread(mergeBreakpoints))), getAreaBreakpoints_createContext(areaName)), []);\n      };\n      /* harmony default export */\n\n\n      var breakpoints_getAreaBreakpoints_getAreaBreakpoints = getAreaBreakpoints_getAreaBreakpoints; // CONCATENATED MODULE: ./src/utils/breakpoints/getAreaBreakpoints/index.ts\n      // CONCATENATED MODULE: ./src/utils/templates/generateComponents/generateComponents.tsx\n\n      function generateComponents_typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          generateComponents_typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          generateComponents_typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return generateComponents_typeof(obj);\n      }\n\n      function generateComponents_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            generateComponents_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function generateComponents_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function _extends() {\n        _extends = Object.assign || function (target) {\n          for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            for (var key in source) {\n              if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n              }\n            }\n          }\n\n          return target;\n        };\n\n        return _extends.apply(this, arguments);\n      }\n\n      function generateComponents_objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n        var target = generateComponents_objectWithoutPropertiesLoose(source, excluded);\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n          for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n      function generateComponents_objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n          key = sourceKeys[i];\n          if (excluded.indexOf(key) >= 0) continue;\n          target[key] = source[key];\n        }\n\n        return target;\n      }\n      /**\n       * A high-order component that wraps the given area component in a placeholder.\n       * This is used for conditional components, where placeholder component is rendered\n       * until the condition for the area component is met (i.e. breakpoint).\n       */\n\n\n      var generateComponents_withPlaceholder = function withPlaceholder(Component, breakpoints) {\n        var Placeholder = function Placeholder(_ref) {\n          var children = _ref.children,\n              restProps = generateComponents_objectWithoutProperties(_ref, [\"children\"]);\n          return breakpoints.filter(Boolean).reduce(function (components, breakpointProps, index) {\n            var behavior = breakpointProps.behavior,\n                queryProps = generateComponents_objectWithoutProperties(breakpointProps, [\"behavior\"]);\n            return components.concat(external_react_[\"createElement\"](components_MediaQuery, _extends({}, queryProps, {\n              key: \"\".concat(Component.displayName, \"_\").concat(index)\n            }), function (matches) {\n              return matches && external_react_[\"createElement\"](Component, restProps, children);\n            }));\n          }, []);\n        };\n\n        Placeholder.displayName = \"Placeholder(\".concat(Component.displayName, \")\");\n        return Placeholder;\n      };\n\n      var generateComponents_createAreaComponent = function createAreaComponent(areaName) {\n        return function (props) {\n          return external_react_[\"createElement\"](components_Box, _extends({\n            area: areaName\n          }, props));\n        };\n      };\n      /**\n       * Returns a map of React components based on the given grid areas\n       * in the given template definitions.\n       */\n\n\n      function generateComponents(_ref2) {\n        var areas = _ref2.areas,\n            templates = _ref2.templates;\n        var componentsMap = areas.reduce(function (components, areaName) {\n          var areaParams = breakpoints_getAreaBreakpoints_getAreaBreakpoints(areaName, templates);\n          var shouldAlwaysRender = areaParams.length === 1 && areaParams.every(function (breakpoint) {\n            return !breakpoint.minWidth && !breakpoint.maxWidth;\n          });\n          var Component = generateComponents_createAreaComponent(areaName);\n          var capitalizedAreaName = capitalize(areaName);\n          Component.displayName = capitalizedAreaName;\n          var ResponsiveComponent = shouldAlwaysRender ? Component : generateComponents_withPlaceholder(Component, areaParams);\n          return generateComponents_objectSpread({}, components, generateComponents_defineProperty({}, capitalizedAreaName, ResponsiveComponent));\n        }, {});\n        /**\n         * Return plain components map for browsers that don't support Proxy.\n         * Requires safety check before rendering conditional areas.\n         */\n\n        return typeof Proxy === 'undefined' ? componentsMap : new Proxy(componentsMap, {\n          get: function get(components, areaName) {\n            if (areaName in components || generateComponents_typeof(areaName) === 'symbol') {\n              return components[areaName];\n            } // @ts-ignore-line\n\n\n            if (false) {}\n            /**\n             * Replace non-existing area component with\n             * the dummy component that renders nothing.\n             * This prevents from the exception when rendering \"undefined\"\n             * and allows conditional template areas.\n             */\n\n\n            return function () {\n              return null;\n            };\n          }\n        });\n      } // CONCATENATED MODULE: ./src/utils/templates/generateComponents/index.ts\n      // CONCATENATED MODULE: ./src/utils/strings/sanitizeTemplateString/sanitizeTemplateString.ts\n\n      /**\n       * Returns an array of unique normalized grid areas\n       * from the given template string.\n       */\n\n\n      var sanitizeTemplateString = compose(function (list) {\n        return list.sort();\n      },\n      /* Deduplicates area strings */\n      function (list) {\n        return Array.from(new Set(list));\n      },\n      /* Filters out empty area strings */\n      function (arr) {\n        return arr.filter(Boolean);\n      },\n      /* Splits into a list of areas */\n      function (str) {\n        return str.split(' ');\n      },\n      /* Deduplicates multiple spaces */\n      function (str) {\n        return str.replace(/\\s+/g, ' ');\n      },\n      /* Replaces newlines and single quotes with spaces */\n      function (str) {\n        return str.replace(/\\r?\\n|\\'+/g, ' ');\n      });\n      /* harmony default export */\n\n      var sanitizeTemplateString_sanitizeTemplateString = sanitizeTemplateString; // CONCATENATED MODULE: ./src/utils/strings/sanitizeTemplateString/index.ts\n      // CONCATENATED MODULE: ./src/utils/templates/parseTemplates/filterTemplateProps.ts\n\n      function filterTemplateProps_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            filterTemplateProps_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function filterTemplateProps_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n      /**\n       * Accepts a props object and filters it to include\n       * only template-related prop:value pairs.\n       */\n\n\n      var filterTemplateProps_filterTemplateProps = function filterTemplateProps(props) {\n        return Object.keys(props).filter(function (propName) {\n          var _parsePropName = parsePropName(propName),\n              purePropName = _parsePropName.purePropName;\n\n          return ['areas', 'template'].includes(purePropName);\n        }).reduce(function (acc, propName) {\n          return filterTemplateProps_objectSpread({}, acc, filterTemplateProps_defineProperty({}, propName, sanitizeTemplateString_sanitizeTemplateString(props[propName])));\n        }, {});\n      };\n      /* harmony default export */\n\n\n      var parseTemplates_filterTemplateProps = filterTemplateProps_filterTemplateProps; // CONCATENATED MODULE: ./src/utils/templates/parseTemplates/parseTemplates.ts\n\n      function parseTemplates_slicedToArray(arr, i) {\n        return parseTemplates_arrayWithHoles(arr) || parseTemplates_iterableToArrayLimit(arr, i) || parseTemplates_nonIterableRest();\n      }\n\n      function parseTemplates_nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      function parseTemplates_iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function parseTemplates_arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n      /**\n       * Memoize areas generation based on the sanitized \"templateProp:areas\" pairs.\n       * Alphabetical sorting of incoming template areas allows reproducible cache keys.\n       * @todo `pairs` is an empty array sometimes. Should we handle it somehow?\n       */\n\n\n      var memoized = memoizeWith(function (templateProps) {\n        var pairs = Object.entries(templateProps).reduce(function (acc, _ref) {\n          var _ref2 = parseTemplates_slicedToArray(_ref, 2),\n              propName = _ref2[0],\n              templateAreas = _ref2[1];\n\n          return acc.concat(\"\".concat(propName, \":\").concat(templateAreas.join()));\n        }, []);\n        return hashString(pairs.join()).toString();\n      });\n      var parseTemplates = compose(memoized(compose(generateComponents, getAreasList)), parseTemplates_filterTemplateProps);\n      /* harmony default export */\n\n      var parseTemplates_parseTemplates = parseTemplates; // CONCATENATED MODULE: ./src/utils/templates/parseTemplates/index.ts\n      // CONCATENATED MODULE: ./src/components/Composition.tsx\n\n      function Composition_typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          Composition_typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          Composition_typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return Composition_typeof(obj);\n      }\n\n      function Composition_objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n        var target = Composition_objectWithoutPropertiesLoose(source, excluded);\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n          for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n      function Composition_objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n          key = sourceKeys[i];\n          if (excluded.indexOf(key) >= 0) continue;\n          target[key] = source[key];\n        }\n\n        return target;\n      }\n\n      function Composition_templateObject() {\n        var data = Composition_taggedTemplateLiteral([\"\\n  && {\\n    \", \";\\n    display: \", \";\\n  }\\n\"]);\n\n        Composition_templateObject = function _templateObject() {\n          return data;\n        };\n\n        return data;\n      }\n\n      function Composition_taggedTemplateLiteral(strings, raw) {\n        if (!raw) {\n          raw = strings.slice(0);\n        }\n\n        return Object.freeze(Object.defineProperties(strings, {\n          raw: {\n            value: Object.freeze(raw)\n          }\n        }));\n      }\n\n      var CompositionWrapper = external_styled_components_default.a.div(Composition_templateObject(), applyStyles, function (_ref) {\n        var inline = _ref.inline;\n        return inline ? 'inline-grid' : 'grid';\n      });\n\n      var Composition_Composition = function Composition(_ref2) {\n        var children = _ref2.children,\n            restProps = Composition_objectWithoutProperties(_ref2, [\"children\"]);\n        var areaComponents = parseTemplates_parseTemplates(restProps);\n        var hasAreaComponents = Object.keys(areaComponents).length > 0;\n        var childrenType = Composition_typeof(children);\n        var hasChildrenFunction = childrenType === 'function'; // Warn on attempt to use \"areas\"/\"template\" props without children-as-function.\n        // Render in that case still occurs, but it doesn't produce the expected result.\n\n        warn(!(hasAreaComponents && !hasChildrenFunction), \"Failed to render 'Composition' with template areas [\\\"\".concat(Object.keys(areaComponents).join('\", \"'), \"\\\"]: expected children to be a function, but got: \").concat(childrenType, \". Please provide render function as children, or remove assigned template props.\"));\n        return external_react_[\"createElement\"](CompositionWrapper, restProps, hasAreaComponents && hasChildrenFunction ? children(areaComponents) : children);\n      };\n      /* harmony default export */\n\n\n      var components_Composition = Composition_Composition; // CONCATENATED MODULE: ./src/utils/breakpoints/closeBreakpoint/closeBreakpoint.ts\n\n      function closeBreakpoint_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            closeBreakpoint_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function closeBreakpoint_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function closeBreakpoint_slicedToArray(arr, i) {\n        return closeBreakpoint_arrayWithHoles(arr) || closeBreakpoint_iterableToArrayLimit(arr, i) || closeBreakpoint_nonIterableRest();\n      }\n\n      function closeBreakpoint_nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      function closeBreakpoint_iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function closeBreakpoint_arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n      /**\n       * Accepts a breakpoint and returns a new breakpoint where\n       * all the \"min\" properties of the original breakpoint are\n       * flipped into the \"max\" properties. Any \"max\" properties\n       * of the original breakpoint are omitted.\n       *\n       * @example\n       * flipBreakpoint({ minWidth: 500, maxWidth: 600 })\n       * // { maxWidth: 499 }\n       */\n\n\n      function flipBreakpoint(breakpoint) {\n        return Object.entries(breakpoint).map(function (_ref) {\n          var _ref2 = closeBreakpoint_slicedToArray(_ref, 2),\n              propName = _ref2[0],\n              propValue = _ref2[1];\n\n          return [getPrefix(propName), propName, propValue];\n        }).filter(function (_ref3) {\n          var _ref4 = closeBreakpoint_slicedToArray(_ref3, 1),\n              prefix = _ref4[0];\n\n          return prefix !== 'max';\n        }).reduce(function (newBreakpoint, _ref5) {\n          var _ref6 = closeBreakpoint_slicedToArray(_ref5, 3),\n              prefix = _ref6[0],\n              propName = _ref6[1],\n              propValue = _ref6[2];\n\n          var hasMinPrefix = prefix === 'min';\n          var nextPropName = hasMinPrefix ? propName.replace(/^min/, 'max') : propName;\n          /**\n           * Subtracts 1 from the edge to not include the area at the beginning\n           * of the breakpoint.\n           *\n           * @todo\n           * How is \"parseFloat\" going to work with non-dimensional options?\n           * (i.e. aspectRatio)\n           */\n\n          var nextValue = hasMinPrefix ? parseFloat(String(propValue)) - 1 : propValue;\n          return closeBreakpoint_objectSpread({}, newBreakpoint, closeBreakpoint_defineProperty({}, nextPropName, nextValue));\n        }, {});\n      } // CONCATENATED MODULE: ./src/utils/breakpoints/closeBreakpoint/index.ts\n      // CONCATENATED MODULE: ./src/components/Only.tsx\n\n\n      function Only_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            Only_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function Only_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function Only_objectWithoutProperties(source, excluded) {\n        if (source == null) return {};\n        var target = Only_objectWithoutPropertiesLoose(source, excluded);\n        var key, i;\n\n        if (Object.getOwnPropertySymbols) {\n          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n          for (i = 0; i < sourceSymbolKeys.length; i++) {\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n      function Only_objectWithoutPropertiesLoose(source, excluded) {\n        if (source == null) return {};\n        var target = {};\n        var sourceKeys = Object.keys(source);\n        var key, i;\n\n        for (i = 0; i < sourceKeys.length; i++) {\n          key = sourceKeys[i];\n          if (excluded.indexOf(key) >= 0) continue;\n          target[key] = source[key];\n        }\n\n        return target;\n      }\n\n      var Only_resolveBreakpoint = function resolveBreakpoint(breakpointRef) {\n        return typeof breakpointRef === 'string' ? src_Layout.getBreakpoint(breakpointRef) : breakpointRef;\n      };\n\n      var Only_createWrapper = function createWrapper(children, props) {\n        return function () {\n          for (var _len = arguments.length, breakpoints = new Array(_len), _key = 0; _key < _len; _key++) {\n            breakpoints[_key] = arguments[_key];\n          }\n\n          var Placeholder = generateComponents_withPlaceholder(components_Box, breakpoints);\n          return external_react_[\"createElement\"](Placeholder, props, children);\n        };\n      };\n\n      var Only_Only = function Only(_ref) {\n        var children = _ref.children,\n            except = _ref.except,\n            exactBreakpointName = _ref[\"for\"],\n            minBreakpointName = _ref.from,\n            maxBreakpointName = _ref.to,\n            restProps = Only_objectWithoutProperties(_ref, [\"children\", \"except\", \"for\", \"from\", \"to\"]);\n        var wrapWith = Only_createWrapper(children, restProps);\n        /* Render on explicit breakpoint */\n\n        if (exactBreakpointName) {\n          return wrapWith(Only_resolveBreakpoint(exactBreakpointName));\n        }\n\n        var minBreakpoint = Only_resolveBreakpoint(minBreakpointName);\n        var maxBreakpoint = Only_resolveBreakpoint(maxBreakpointName);\n        /* Bell, __/--\\__ */\n\n        if (minBreakpoint && maxBreakpoint && !except) {\n          return wrapWith(mergeBreakpoints(Only_objectSpread({\n            behavior: 'down'\n          }, maxBreakpoint), Only_objectSpread({\n            behavior: 'up'\n          }, minBreakpoint), false));\n        }\n        /* Notch, --\\__/-- */\n\n\n        if (minBreakpoint && maxBreakpoint && except) {\n          return wrapWith(flipBreakpoint(minBreakpoint), openBreakpoint(maxBreakpoint));\n        }\n        /* High-pass, __/-- */\n\n\n        if (minBreakpoint && !maxBreakpoint) {\n          return wrapWith(openBreakpoint(minBreakpoint));\n        }\n        /* Low-pass, --\\__ */\n\n\n        if (!minBreakpoint && maxBreakpoint) {\n          return wrapWith(flipBreakpoint(maxBreakpoint));\n        }\n        /* Render always when no constrains are provided */\n\n\n        return children;\n      };\n      /* harmony default export */\n\n\n      var components_Only = Only_Only; // CONCATENATED MODULE: ./src/utils/functions/debounce/debounce.ts\n\n      function debounce(func) {\n        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;\n        var timeout;\n        return function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          var postpone = function postpone() {\n            timeout = null;\n            return func.apply(void 0, args);\n          };\n\n          clearTimeout(timeout);\n          timeout = setTimeout(postpone, duration);\n        };\n      } // CONCATENATED MODULE: ./src/utils/functions/debounce/index.ts\n      // CONCATENATED MODULE: ./src/hooks/useViewportChange.ts\n\n      /**\n       * Executes a given callback on debounced window resize.\n       */\n\n\n      var useViewportChange_useViewportChange = function useViewportChange(callback, debounceDuration) {\n        var handleWindowResize = debounce(callback, debounceDuration);\n        Object(external_react_[\"useEffect\"])(function () {\n          handleWindowResize();\n          window.addEventListener('resize', handleWindowResize);\n          return function () {\n            return window.removeEventListener('resize', handleWindowResize);\n          };\n        }, []);\n      };\n      /* harmony default export */\n\n\n      var hooks_useViewportChange = useViewportChange_useViewportChange; // CONCATENATED MODULE: ./src/hooks/useBreakpointChange.ts\n\n      var useBreakpointChange_useBreakpointChange = function useBreakpointChange(callback, debounceDuration) {\n        var breakpoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : src_Layout.breakpoints;\n        var prevBreakpointName;\n        hooks_useViewportChange(function () {\n          var nextBreakpointName = Object.keys(breakpoints).find(function (breakpointName) {\n            var mediaQuery = createMediaQuery_createMediaQuery(breakpoints[breakpointName], 'only');\n            return matchMedia(mediaQuery).matches;\n          });\n\n          if (prevBreakpointName !== nextBreakpointName) {\n            callback(nextBreakpointName);\n            prevBreakpointName = nextBreakpointName;\n          }\n        });\n      };\n      /* harmony default export */\n\n\n      var hooks_useBreakpointChange = useBreakpointChange_useBreakpointChange; // CONCATENATED MODULE: ./src/utils/breakpoints/withBreakpoints/withBreakpoints.ts\n\n      var withBreakpoints_createWithBreakpoints = function createWithBreakpoints(breakpoints) {\n        var existingBreakpoints = Object.keys(breakpoints);\n        return function (breakpointsMap, defaultValue) {\n          var breakpointMatch = Object.keys(breakpointsMap).filter(function (breakpointName) {\n            var hasBreakpoint = existingBreakpoints.includes(breakpointName);\n\n            if (!hasBreakpoint) {\n              console.warn('useBreakpoints: Breakpoint \"%s\" is not found. Add it via \"Layout.configure()\", or use one of the existing breakpoints (%s).', breakpointName, existingBreakpoints.join(', '));\n            }\n\n            return hasBreakpoint;\n          }).find(function (breakpointName) {\n            var breakpoint = breakpoints[breakpointName];\n            var mediaQuery = createMediaQuery_createMediaQuery(breakpoint, 'only');\n            return breakpoint && matchMedia(mediaQuery).matches;\n          });\n          return breakpointMatch ? breakpointsMap[breakpointMatch] : defaultValue;\n        };\n      };\n\n      var withBreakpoints = withBreakpoints_createWithBreakpoints(src_Layout.breakpoints);\n      /* harmony default export */\n\n      var withBreakpoints_withBreakpoints = withBreakpoints; // CONCATENATED MODULE: ./src/utils/breakpoints/withBreakpoints/index.ts\n      // CONCATENATED MODULE: ./src/hooks/useResponsiveValue.ts\n\n      function useResponsiveValue_slicedToArray(arr, i) {\n        return useResponsiveValue_arrayWithHoles(arr) || useResponsiveValue_iterableToArrayLimit(arr, i) || useResponsiveValue_nonIterableRest();\n      }\n\n      function useResponsiveValue_nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      function useResponsiveValue_iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function useResponsiveValue_arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n      /**\n       * Accepts a map of { breakpointName: value } pairs\n       * and returns a value based on the current viewport.\n       * Returns default value when no matching pair is found.\n       */\n\n\n      var useResponsiveValue_useResponsiveValue = function useResponsiveValue(breakpoints, defaultValue) {\n        var _useState = Object(external_react_[\"useState\"])(defaultValue),\n            _useState2 = useResponsiveValue_slicedToArray(_useState, 2),\n            value = _useState2[0],\n            updateValue = _useState2[1];\n\n        hooks_useBreakpointChange(function () {\n          var nextValue = withBreakpoints_withBreakpoints(breakpoints, defaultValue);\n          updateValue(nextValue);\n        });\n        return value;\n      };\n      /* harmony default export */\n\n\n      var hooks_useResponsiveValue = useResponsiveValue_useResponsiveValue; // CONCATENATED MODULE: ./src/hooks/useResponsiveProps.ts\n\n      function useResponsiveProps_objectSpread(target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i] != null ? arguments[i] : {};\n          var ownKeys = Object.keys(source);\n\n          if (typeof Object.getOwnPropertySymbols === 'function') {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n              return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n          }\n\n          ownKeys.forEach(function (key) {\n            useResponsiveProps_defineProperty(target, key, source[key]);\n          });\n        }\n\n        return target;\n      }\n\n      function useResponsiveProps_defineProperty(obj, key, value) {\n        if (key in obj) {\n          Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } else {\n          obj[key] = value;\n        }\n\n        return obj;\n      }\n\n      function useResponsiveProps_slicedToArray(arr, i) {\n        return useResponsiveProps_arrayWithHoles(arr) || useResponsiveProps_iterableToArrayLimit(arr, i) || useResponsiveProps_nonIterableRest();\n      }\n\n      function useResponsiveProps_nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n      }\n\n      function useResponsiveProps_iterableToArrayLimit(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n\n        try {\n          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n\n            if (i && _arr.length === i) break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n          } finally {\n            if (_d) throw _e;\n          }\n        }\n\n        return _arr;\n      }\n\n      function useResponsiveProps_arrayWithHoles(arr) {\n        if (Array.isArray(arr)) return arr;\n      }\n      /**\n       * Accepts an object of responsive props and returns\n       * an object of props relative to the current viewport.\n       */\n\n\n      var useResponsiveProps_useResponsiveProps = function useResponsiveProps(responsiveProps) {\n        var _useState = Object(external_react_[\"useState\"])({}),\n            _useState2 = useResponsiveProps_slicedToArray(_useState, 2),\n            props = _useState2[0],\n            setProps = _useState2[1];\n\n        hooks_useBreakpointChange(function () {\n          var relevantProps = Object.keys(responsiveProps).map(parsePropName).filter(function (_ref) {\n            var breakpoint = _ref.breakpoint,\n                behavior = _ref.behavior;\n            var mediaQuery = createMediaQuery_createMediaQuery(src_Layout.breakpoints[breakpoint.name], behavior);\n            return matchMedia(mediaQuery).matches;\n          }).reduce(function (acc, _ref2) {\n            var originPropName = _ref2.originPropName,\n                purePropName = _ref2.purePropName;\n            return useResponsiveProps_objectSpread({}, acc, useResponsiveProps_defineProperty({}, purePropName, responsiveProps[originPropName]));\n          }, {});\n          setProps(relevantProps);\n        });\n        return props;\n      };\n      /* harmony default export */\n\n\n      var hooks_useResponsiveProps = useResponsiveProps_useResponsiveProps; // CONCATENATED MODULE: ./src/index.ts\n\n      /* concated harmony reexport Box */\n\n      __webpack_require__.d(__webpack_exports__, \"Box\", function () {\n        return components_Box;\n      });\n      /* concated harmony reexport Composition */\n\n\n      __webpack_require__.d(__webpack_exports__, \"Composition\", function () {\n        return components_Composition;\n      });\n      /* concated harmony reexport Only */\n\n\n      __webpack_require__.d(__webpack_exports__, \"Only\", function () {\n        return components_Only;\n      });\n      /* concated harmony reexport MediaQuery */\n\n\n      __webpack_require__.d(__webpack_exports__, \"MediaQuery\", function () {\n        return components_MediaQuery;\n      });\n      /* concated harmony reexport useViewportChange */\n\n\n      __webpack_require__.d(__webpack_exports__, \"useViewportChange\", function () {\n        return hooks_useViewportChange;\n      });\n      /* concated harmony reexport useResponsiveValue */\n\n\n      __webpack_require__.d(__webpack_exports__, \"useResponsiveValue\", function () {\n        return hooks_useResponsiveValue;\n      });\n      /* concated harmony reexport useBreakpointChange */\n\n\n      __webpack_require__.d(__webpack_exports__, \"useBreakpointChange\", function () {\n        return hooks_useBreakpointChange;\n      });\n      /* concated harmony reexport useResponsiveProps */\n\n\n      __webpack_require__.d(__webpack_exports__, \"useResponsiveProps\", function () {\n        return hooks_useResponsiveProps;\n      });\n      /* concated harmony reexport withBreakpoints */\n\n\n      __webpack_require__.d(__webpack_exports__, \"withBreakpoints\", function () {\n        return withBreakpoints_withBreakpoints;\n      });\n      /* harmony default export */\n\n\n      var src = __webpack_exports__[\"default\"] = src_Layout;\n      /* Components */\n\n      /* Hooks */\n\n      /* Utils */\n\n      /***/\n    }])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}