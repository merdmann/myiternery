(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("styled-components"));
	else if(typeof define === 'function' && define.amd)
		define("atomicLayout", ["react", "styled-components"], factory);
	else if(typeof exports === 'object')
		exports["atomicLayout"] = factory(require("react"), require("styled-components"));
	else
		root["atomicLayout"] = factory(root["react"], root["styled-components"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__1__;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./src/const/defaultOptions.ts
var defaultOptions = {
  defaultUnit: 'px',
  defaultBehavior: 'up',
  defaultBreakpointName: 'xs',
  breakpoints: {
    xs: {
      maxWidth: '575px'
    },
    sm: {
      minWidth: '576px',
      maxWidth: '768px'
    },
    md: {
      minWidth: '769px',
      maxWidth: '992px'
    },
    lg: {
      minWidth: '993px',
      maxWidth: '1199px'
    },
    xl: {
      minWidth: '1200px'
    }
  }
};
/* harmony default export */ var const_defaultOptions = (defaultOptions);
// CONCATENATED MODULE: ./src/utils/invariant/invariant.ts
function invariant(variable, message) {
  if (!variable) {
    throw new Error(message);
  }
}
// CONCATENATED MODULE: ./src/utils/invariant/index.ts


// CONCATENATED MODULE: ./src/utils/functions/warn/warn.ts
function warn(predicate, message) {
  if (!predicate) {
    console.warn(message);
  }
}
// CONCATENATED MODULE: ./src/utils/functions/warn/index.ts


// CONCATENATED MODULE: ./src/Layout.ts
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var Layout_Layout =
/*#__PURE__*/
function () {
  function Layout(options) {
    _classCallCheck(this, Layout);

    _defineProperty(this, "defaultUnit", const_defaultOptions.defaultUnit);

    _defineProperty(this, "defaultBehavior", const_defaultOptions.defaultBehavior);

    _defineProperty(this, "breakpoints", const_defaultOptions.breakpoints);

    _defineProperty(this, "defaultBreakpointName", const_defaultOptions.defaultBreakpointName);

    _defineProperty(this, "isConfigureCalled", false);

    return options ? this.configure(options, false) : this;
  }
  /**
   * Applies global layout options.
   */


  _createClass(Layout, [{
    key: "configure",
    value: function configure(options) {
      var _this = this;

      var warnOnMultiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (warnOnMultiple) {
        warn(!this.isConfigureCalled, 'Failed to configure Layout: do not call `Layout.configure()` more than once. Layout configuration must remain consistent throughout the application.');
      }

      invariant(options && _typeof(options) === 'object', "Failed to configure Layout: expected an options Object, but got: ".concat(options, "."));
      Object.keys(options || {}).forEach(function (optionName) {
        _this[optionName] = options[optionName];
      });
      invariant(this.breakpoints, 'Failed to configure Layout: expected to have at least one breakpoint specified, but got none.');
      invariant(this.breakpoints.hasOwnProperty(this.defaultBreakpointName), "Failed to configure Layout: cannot use \"".concat(this.defaultBreakpointName, "\" as the default breakpoint (breakpoint not found)."));
      invariant(this.defaultBreakpointName, "Failed to configure Layout: expected \"defaultBreakpointName\" property set, but got: ".concat(this.defaultBreakpointName, ".")); // invariant(
      //   typeof this.defaultBreakpointName === 'string',
      //   `Failed to configure Layout: expected "defaultBreakpointName" to be a string, but got: ${typeof this
      //     .defaultBreakpointName}`,
      // )
      // Mark configure method as called to prevent its multiple calls

      this.isConfigureCalled = warnOnMultiple;
      return this;
    }
    /**
     * Returns the collection of breakpoint names present
     * in the current layout configuration.
     */

  }, {
    key: "getBreakpointNames",
    value: function getBreakpointNames() {
      return Object.keys(this.breakpoints);
    }
    /**
     * Returns breakpoint options by the given breakpoint name.
     */

  }, {
    key: "getBreakpoint",
    value: function getBreakpoint(breakpointName) {
      return this.breakpoints[breakpointName];
    }
  }]);

  return Layout;
}();

/* harmony default export */ var src_Layout = (new Layout_Layout());
// EXTERNAL MODULE: external "styled-components"
var external_styled_components_ = __webpack_require__(1);
var external_styled_components_default = /*#__PURE__*/__webpack_require__.n(external_styled_components_);

// CONCATENATED MODULE: ./src/utils/functions/compose/compose.ts
/**
 * Returns a functional composition of the given functions.
 * Applies no currying.
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return funcs.reduce(function (f, g) {
    return function () {
      return f(g.apply(void 0, arguments));
    };
  });
}
// CONCATENATED MODULE: ./src/utils/functions/compose/index.ts


// CONCATENATED MODULE: ./src/utils/functions/isset/isset.ts
function isset(variable) {
  return typeof variable !== 'undefined' && variable !== null;
}
// CONCATENATED MODULE: ./src/utils/functions/isset/index.ts


// CONCATENATED MODULE: ./src/utils/math/transformNumeric.ts


function transformNumeric(value) {
  if (!isset(value)) {
    return '';
  }
  /**
   * Suffix numeric value with the default unit.
   * Accept explicit (string) value as-is.
   *
   * When given value is zero then its generated as it is, no suffix is attached
   */


  var suffix = typeof value === 'number' && value !== 0 ? src_Layout.defaultUnit : '';
  return "".concat(value).concat(suffix);
}
// CONCATENATED MODULE: ./src/utils/strings/sanitizeTemplateArea/sanitizeTemplateArea.ts


/**
 * Trims whitespace, removes duplicate single quotes and enforces
 * that area line is wrapped in single quotes.
 */
var sanitizeTemplateArea = compose(function (area) {
  return area.replace(/^.+$/gm, function (areaName) {
    return "'".concat(areaName, "'");
  });
}, function (area) {
  return area.replace(/'+/gm, '');
}, function (area) {
  return area.trim();
});
/* harmony default export */ var sanitizeTemplateArea_sanitizeTemplateArea = (sanitizeTemplateArea);
// CONCATENATED MODULE: ./src/utils/strings/sanitizeTemplateArea/index.ts


// CONCATENATED MODULE: ./src/const/propAliases.ts



var transformTemplateString = compose(function (areas) {
  return areas.join('\n');
}, function (areas) {
  return areas.map(sanitizeTemplateArea_sanitizeTemplateArea);
}, function (template) {
  return template.split('\n');
}, function (template) {
  return template.trim();
});
/**
 * Collection of prop aliases.
 * Prop alias is a prop name accepted by a component which is later
 * substituted by one or multiple CSS properties with a single value.
 * Each prop value can have a value transformer.
 */

var propAliases = {
  /* CSS Grid */
  area: {
    props: ['grid-area']
  },
  areas: {
    props: ['grid-template-areas'],
    transformValue: transformTemplateString
  },
  template: {
    props: ['grid-template-areas'],
    transformValue: transformTemplateString
  },
  templateCols: {
    props: ['grid-template-columns']
  },
  templateRows: {
    props: ['grid-template-rows']
  },
  col: {
    props: ['grid-column']
  },
  colStart: {
    props: ['grid-column-start']
  },
  colEnd: {
    props: ['grid-column-end']
  },
  row: {
    props: ['grid-row']
  },
  rowStart: {
    props: ['grid-row-start']
  },
  rowEnd: {
    props: ['grid-row-end']
  },
  gap: {
    props: ['grid-gap'],
    transformValue: transformNumeric
  },
  gapCol: {
    props: ['grid-column-gap'],
    transformValue: transformNumeric
  },
  gapRow: {
    props: ['grid-row-gap'],
    transformValue: transformNumeric
  },
  gutter: {
    props: ['grid-gap'],
    transformValue: transformNumeric
  },
  gutterCol: {
    props: ['grid-column-gap'],
    transformValue: transformNumeric
  },
  gutterRow: {
    props: ['grid-row-gap'],
    transformValue: transformNumeric
  },
  autoRows: {
    props: ['grid-auto-rows'],
    transformValue: transformNumeric
  },
  autoCols: {
    props: ['grid-auto-columns'],
    transformValue: transformNumeric
  },
  autoFlow: {
    props: ['grid-auto-flow']
  },
  align: {
    props: ['align-self']
  },
  alignItems: {
    props: ['align-items']
  },
  justify: {
    props: ['justify-self']
  },
  justifyItems: {
    props: ['justify-items']
  },
  justifyContent: {
    props: ['justify-content']
  },
  place: {
    props: ['place-self']
  },
  placeItems: {
    props: ['place-items']
  },
  placeContent: {
    props: ['place-content']
  },

  /* CSS Flexbox */
  flexDirection: {
    props: ['flex-direction']
  },
  flexShrink: {
    props: ['flex-shrink']
  },
  flexGrow: {
    props: ['flex-grow']
  },
  flexWrap: {
    props: ['flex-wrap']
  },

  /* Dimensions */
  height: {
    props: ['height'],
    transformValue: transformNumeric
  },
  minHeight: {
    props: ['min-height'],
    transformValue: transformNumeric
  },
  maxHeight: {
    props: ['max-height'],
    transformValue: transformNumeric
  },
  width: {
    props: ['width'],
    transformValue: transformNumeric
  },
  minWidth: {
    props: ['min-width'],
    transformValue: transformNumeric
  },
  maxWidth: {
    props: ['max-width'],
    transformValue: transformNumeric
  },

  /* Space */
  margin: {
    props: ['margin'],
    transformValue: transformNumeric
  },
  marginTop: {
    props: ['margin-top'],
    transformValue: transformNumeric
  },
  marginRight: {
    props: ['margin-right'],
    transformValue: transformNumeric
  },
  marginBottom: {
    props: ['margin-bottom'],
    transformValue: transformNumeric
  },
  marginLeft: {
    props: ['margin-left'],
    transformValue: transformNumeric
  },
  marginVertical: {
    props: ['margin-top', 'margin-bottom'],
    transformValue: transformNumeric
  },
  marginHorizontal: {
    props: ['margin-right', 'margin-left'],
    transformValue: transformNumeric
  },
  padding: {
    props: ['padding'],
    transformValue: transformNumeric
  },
  paddingTop: {
    props: ['padding-top'],
    transformValue: transformNumeric
  },
  paddingRight: {
    props: ['padding-right'],
    transformValue: transformNumeric
  },
  paddingBottom: {
    props: ['padding-bottom'],
    transformValue: transformNumeric
  },
  paddingLeft: {
    props: ['padding-left'],
    transformValue: transformNumeric
  },
  paddingVertical: {
    props: ['padding-top', 'padding-bottom'],
    transformValue: transformNumeric
  },
  paddingHorizontal: {
    props: ['padding-right', 'padding-left'],
    transformValue: transformNumeric
  }
};
/* harmony default export */ var const_propAliases = (propAliases);
// CONCATENATED MODULE: ./src/utils/strings/toLowerCaseFirst/toLowerCaseFirst.ts
function toLowerCaseFirst(str) {
  return str.slice(0, 1).toLowerCase() + str.slice(1, str.length);
}
// CONCATENATED MODULE: ./src/utils/strings/toLowerCaseFirst/index.ts


// CONCATENATED MODULE: ./src/utils/strings/parsePropName/parsePropName.ts



/**
 * Returns a parsed prop summary, which includes pure prop name,
 * an optional breakpoint name and breakpoint behavior.
 *
 * \w+(?<=(sm)?(only)?)$
 * This RegExp also works well. May consider implementing once
 * lookbehind is supported everywhere.
 */
function parsePropName(originPropName) {
  var joinedBreakpointNames = src_Layout.getBreakpointNames().join('|');
  var joinedBehaviors = ['down', 'only'].join('|');
  var breakpointExp = new RegExp("(".concat(joinedBreakpointNames, ")$"), 'gi');
  var behaviorExp = new RegExp("(".concat(joinedBehaviors, ")$"), 'gi');
  var behaviorMatch = originPropName.match(behaviorExp);
  var behavior = behaviorMatch ? behaviorMatch[0] : '';
  var breakpointMatch = originPropName.replace(behavior, '').match(breakpointExp);
  var breakpointName = breakpointMatch ? breakpointMatch[0] : '';
  var purePropName = originPropName.replace(breakpointName, '').replace(behavior, '');
  /**
   * Get normalized breakpoint name.
   * When a breakpoint name is a part of the prop name, covert it first letter
   * to lowercase to match the layout options. Otherwise, take the default
   * breakpoint name.
   */

  var normalizedBreakpointName = breakpointName ? toLowerCaseFirst(breakpointName) : src_Layout.defaultBreakpointName;
  var isDefaultBreakpoint = normalizedBreakpointName === src_Layout.defaultBreakpointName;
  return {
    originPropName: originPropName,
    purePropName: purePropName,
    behavior: behavior ? toLowerCaseFirst(behavior) : src_Layout.defaultBehavior,
    breakpoint: {
      name: normalizedBreakpointName,
      isDefault: isDefaultBreakpoint
    }
  };
}
// CONCATENATED MODULE: ./src/utils/strings/parsePropName/index.ts


// CONCATENATED MODULE: ./src/utils/strings/toDashedString/toDashedString.ts
/**
 * @example
 * toDashedString('fooBar') // "foo-bar"
 */
function toDashedString(str) {
  return str.replace(/[A-Z]/g, function (capitalLetter) {
    return "-".concat(capitalLetter).toLowerCase();
  });
}
// CONCATENATED MODULE: ./src/utils/strings/toDashedString/index.ts


// CONCATENATED MODULE: ./src/utils/styles/normalizeQuery/normalizeQuery.ts
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



/**
 * Normalizes given media query object to a list of [propName, propValue].
 * @example
 * normalizeQuery({ minWidth: 120 })
 * // [['min-width', 120]]
 */

function normalizeQuery(queryProps) {
  return Object.entries(queryProps).filter(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        _ = _ref2[0],
        propValue = _ref2[1];

    return isset(propValue);
  }).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        propName = _ref4[0],
        propValue = _ref4[1];

    return [toDashedString(propName), propValue];
  });
}
// CONCATENATED MODULE: ./src/utils/styles/normalizeQuery/index.ts


// CONCATENATED MODULE: ./src/utils/styles/createMediaQuery/createMediaQuery.ts
function createMediaQuery_slicedToArray(arr, i) { return createMediaQuery_arrayWithHoles(arr) || createMediaQuery_iterableToArrayLimit(arr, i) || createMediaQuery_nonIterableRest(); }

function createMediaQuery_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function createMediaQuery_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function createMediaQuery_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




/**
 * Determines whether a given media query param should be added
 * to the media query string based on a breakpoint's behavior.
 */

var shouldAppendProperty = function shouldAppendProperty(queryParam, behavior) {
  var _queryParam$split = queryParam.split('-'),
      _queryParam$split2 = createMediaQuery_slicedToArray(_queryParam$split, 2),
      prefix = _queryParam$split2[0],
      splitPropName = _queryParam$split2[1];

  var isDimensionalProp = ['height', 'width'].includes(splitPropName);

  if (!isDimensionalProp) {
    return true;
  }

  return prefix === 'min' && ['up', 'only'].includes(behavior) || prefix === 'max' && ['down', 'only'].includes(behavior);
};

var filterRelevantQueryParams = function filterRelevantQueryParams(behavior) {
  return function (queryList) {
    return queryList.filter(function (_ref) {
      var _ref2 = createMediaQuery_slicedToArray(_ref, 1),
          queryParam = _ref2[0];

      return shouldAppendProperty(queryParam, behavior);
    });
  };
};
/**
 * Joins a given query params list with the given transformer function.
 */


var joinQueryList = function joinQueryList(transformer) {
  return function (queryList) {
    return queryList.map(transformer).join(' and ');
  };
};
function createMediaQuery_createMediaQuery(breakpoint, behavior) {
  return compose(joinQueryList(function (_ref3) {
    var _ref4 = createMediaQuery_slicedToArray(_ref3, 2),
        dashedQueryProp = _ref4[0],
        propValue = _ref4[1];

    return "(".concat(dashedQueryProp, ":").concat(String(transformNumeric(propValue)), ")");
  }), filterRelevantQueryParams(behavior), normalizeQuery)(breakpoint);
}
// CONCATENATED MODULE: ./src/utils/styles/createMediaQuery/index.ts


// CONCATENATED MODULE: ./src/utils/styles/applyStyles/applyStyles.ts






var applyStyles_createStyleString = function createStyleString(propsList, propValue, breakpoint, behavior) {
  var styleProps = propsList.map(function (propName) {
    return "".concat(propName, ":").concat(String(propValue), ";");
  }).join('');
  var breakpointOptions = src_Layout.getBreakpoint(breakpoint.name);
  /**
   * Wrap CSS rule in a media query only if its prop includes
   * a breakpoint and behavior different than the default ones.
   */

  var shouldWrapInMediaQuery = breakpointOptions && !(breakpoint.isDefault && behavior === src_Layout.defaultBehavior);
  return shouldWrapInMediaQuery ? "@media ".concat(createMediaQuery_createMediaQuery(breakpointOptions, behavior), " {").concat(styleProps, "}") : styleProps;
};

function applyStyles(pristineProps) {
  return Object.keys(pristineProps)
  /* Parse each prop to include "breakpoint" and "behavior" */
  .map(parsePropName)
  /* Filter out props that are not included in prop aliases */
  .filter(function (_ref) {
    var purePropName = _ref.purePropName;
    return const_propAliases.hasOwnProperty(purePropName);
  })
  /* Filter out props with "undefined" or "null" as value */
  .filter(function (_ref2) {
    var originPropName = _ref2.originPropName;
    return isset(pristineProps[originPropName]);
  })
  /* Map each prop to a CSS string */
  .map(function (_ref3) {
    var purePropName = _ref3.purePropName,
        originPropName = _ref3.originPropName,
        breakpoint = _ref3.breakpoint,
        behavior = _ref3.behavior;
    var _propAliases$pureProp = const_propAliases[purePropName],
        props = _propAliases$pureProp.props,
        transformValue = _propAliases$pureProp.transformValue;
    var propValue = pristineProps[originPropName];
    var transformedPropValue = transformValue ? transformValue(propValue) : propValue;
    return applyStyles_createStyleString(props, transformedPropValue, breakpoint, behavior);
  }).join(' ');
}
// CONCATENATED MODULE: ./src/utils/styles/applyStyles/index.ts


// CONCATENATED MODULE: ./src/components/Box.tsx
function _templateObject() {
  var data = _taggedTemplateLiteral(["\n  && {\n    ", ";\n    display: ", ";\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }



var Box = external_styled_components_default.a.div(_templateObject(), applyStyles, function (_ref) {
  var flex = _ref.flex,
      inline = _ref.inline;
  return flex ? inline ? 'inline-flex' : 'flex' : inline ? 'inline-block' : 'block';
});
/* harmony default export */ var components_Box = (Box);
// EXTERNAL MODULE: external "react"
var external_react_ = __webpack_require__(0);

// CONCATENATED MODULE: ./src/utils/functions/memoizeWith/memoizeWith.ts
function memoizeWith(mappingFunc) {
  var cache = {};
  return function (func) {
    return function () {
      var key = mappingFunc.apply(void 0, arguments);

      if (!(key in cache)) {
        cache[key] = func.apply(void 0, arguments);
      }

      return cache[key];
    };
  };
}
// CONCATENATED MODULE: ./src/utils/functions/memoizeWith/index.ts


// CONCATENATED MODULE: ./src/utils/templates/getAreasList/getAreasList.ts
function getAreasList_slicedToArray(arr, i) { return getAreasList_arrayWithHoles(arr) || getAreasList_iterableToArrayLimit(arr, i) || getAreasList_nonIterableRest(); }

function getAreasList_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function getAreasList_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function getAreasList_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



function getAreasList(templateProps) {
  var areasList = Object.entries(templateProps).reduce(function (acc, _ref) {
    var _ref2 = getAreasList_slicedToArray(_ref, 2),
        templateName = _ref2[0],
        templateAreas = _ref2[1];

    var _parsePropName = parsePropName(templateName),
        breakpoint = _parsePropName.breakpoint,
        behavior = _parsePropName.behavior;

    var nextAreas = acc.areas.concat(templateAreas);
    var nextTemplates = acc.templates.concat({
      breakpoint: src_Layout.getBreakpoint(breakpoint.name),
      behavior: behavior,
      areas: templateAreas
    });
    return {
      areas: nextAreas,
      templates: nextTemplates
    };
  }, {
    areas: [],
    templates: []
  });
  var areas = areasList.areas,
      templates = areasList.templates;
  return {
    areas: Array.from(new Set(areas)),
    templates: templates
  };
}
// CONCATENATED MODULE: ./src/utils/templates/getAreasList/index.ts


// CONCATENATED MODULE: ./src/utils/strings/hashString/hashString.ts
function hashString(str) {
  var length = str.length;
  var hash = 0;
  var i = 0;

  if (length > 0) {
    while (i < length) {
      hash = (hash << 5) - hash + str.charCodeAt(i++) | 0;
    }
  }

  return hash;
}
// CONCATENATED MODULE: ./src/utils/strings/hashString/index.ts


// CONCATENATED MODULE: ./src/components/MediaQuery.tsx
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function MediaQuery_slicedToArray(arr, i) { return MediaQuery_arrayWithHoles(arr) || MediaQuery_iterableToArrayLimit(arr, i) || MediaQuery_nonIterableRest(); }

function MediaQuery_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function MediaQuery_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function MediaQuery_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







var MediaQuery_createMediaQuery = function createMediaQuery(queryParams) {
  return compose(joinQueryList(function (_ref) {
    var _ref2 = MediaQuery_slicedToArray(_ref, 2),
        paramName = _ref2[0],
        paramValue = _ref2[1];

    /**
     * Transform values that begin with a number to prevent
     * transformations of "calc" expressions.
     * Transformation of numerics is necessary when a simple
     * number is used as a value (min-width: 750) is not valid.
     *
     * (min-width: 750) ==> (min-width: 750px)
     */
    var resolvedParamValue = /^\d/.test(String(paramValue)) ? transformNumeric(paramValue) : paramValue;
    return "(".concat(paramName, ":").concat(resolvedParamValue, ")");
  }), normalizeQuery)(queryParams);
};

var MediaQuery_MediaQuery = function MediaQuery(props) {
  var children = props.children,
      queryParams = _objectWithoutProperties(props, ["children"]);

  var query = external_react_["useMemo"](function () {
    return MediaQuery_createMediaQuery(queryParams);
  }, [queryParams]);

  var _React$useState = external_react_["useState"](false),
      _React$useState2 = MediaQuery_slicedToArray(_React$useState, 2),
      matches = _React$useState2[0],
      setMatches = _React$useState2[1];

  var handleMediaQueryChange = function handleMediaQueryChange(mediaQueryList) {
    setMatches(mediaQueryList.matches);
  };

  external_react_["useEffect"](function () {
    var mediaQueryList = matchMedia(query);
    handleMediaQueryChange(mediaQueryList);
    mediaQueryList.addListener(handleMediaQueryChange);
    return function () {
      return mediaQueryList.removeListener(handleMediaQueryChange);
    };
  }, Object.keys(queryParams));
  return children(matches);
};

/* harmony default export */ var components_MediaQuery = (MediaQuery_MediaQuery);
// CONCATENATED MODULE: ./src/utils/strings/capitalize/capitalize.ts
function capitalize(str) {
  return str.replace(/^./, function (firstLetter) {
    return firstLetter.toUpperCase();
  });
}
// CONCATENATED MODULE: ./src/utils/strings/capitalize/index.ts


// CONCATENATED MODULE: ./src/utils/functions/pop/pop.ts
/**
 * Returns the shallow copy of the given array with
 * the last element removed.
 */
function pop(list) {
  return list.slice(0, list.length - 1);
}
// CONCATENATED MODULE: ./src/utils/functions/pop/index.ts


// CONCATENATED MODULE: ./src/utils/functions/when/when.ts
function when(predicate, whenTrueFunc) {
  return function (args) {
    return predicate(args) ? whenTrueFunc(args) : args;
  };
}
// CONCATENATED MODULE: ./src/utils/functions/when/index.ts


// CONCATENATED MODULE: ./src/utils/functions/spread/spread.ts
function spread(func) {
  return function (args) {
    return func.apply(null, args);
  };
}
// CONCATENATED MODULE: ./src/utils/functions/spread/index.ts


// CONCATENATED MODULE: ./src/utils/strings/getPrefix/getPrefix.ts
function getPrefix(str) {
  var prompt = str.match(/^(min|max)/);
  return prompt ? prompt[0] : '';
}
// CONCATENATED MODULE: ./src/utils/strings/getPrefix/index.ts


// CONCATENATED MODULE: ./src/utils/breakpoints/mergeBreakpoints/mergeBreakpoints.ts
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { mergeBreakpoints_defineProperty(target, key, source[key]); }); } return target; }

function mergeBreakpoints_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Merges two given mergable breakpoints.
 */

function mergeBreakpoints(breakpointA, breakpointB, includesArea) {
  var prevBehavior = breakpointB.behavior;
  var nextBehavior = breakpointA.behavior;
  var wentUp = prevBehavior === 'up';
  var goesDown = nextBehavior === 'down';
  var behavesSame = prevBehavior === nextBehavior;
  var behavesInclusive = wentUp && goesDown;
  var shouldStretch = wentUp;

  var mergedBreakpoint = _objectSpread({}, breakpointB, breakpointA);

  return Object.keys(mergedBreakpoint).reduce(function (acc, propName) {
    var nextValue = mergedBreakpoint[propName];
    var prefix = getPrefix(propName);

    if (propName === 'behavior') {
      if (!includesArea && shouldStretch) {
        nextValue = 'down';
      }
    }

    if (prefix === 'max') {
      if (!includesArea && shouldStretch) {
        var mirrorValue = breakpointA[propName.replace(/^max/, 'min')];
        nextValue = "calc(".concat(transformNumeric(mirrorValue), " - 1px)");
      }
    }

    if (prefix === 'min') {
      if (includesArea) {
        if (behavesSame || behavesInclusive) {
          nextValue = breakpointB[propName];
        }
      } else {
        if (shouldStretch) {
          nextValue = breakpointB[propName];
        }
      }
    }

    return _objectSpread({}, acc, mergeBreakpoints_defineProperty({}, propName, nextValue));
  }, {
    behavior: const_defaultOptions.defaultBehavior
  });
}
// CONCATENATED MODULE: ./src/utils/breakpoints/mergeBreakpoints/index.ts


// CONCATENATED MODULE: ./src/utils/breakpoints/openBreakpoint/openBreakpoint.ts
function openBreakpoint_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { openBreakpoint_defineProperty(target, key, source[key]); }); } return target; }

function openBreakpoint_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * Opens the given breakpoint.
 * A breakpoint is considered open when it has no upper boundary. For example,
 * a breakpoint that has "maxWidth: undefined" is the open breakpoint.
 */

function openBreakpoint(breakpoint) {
  return Object.keys(breakpoint).reduce(function (acc, key) {
    return openBreakpoint_objectSpread({}, acc, openBreakpoint_defineProperty({}, key, getPrefix(key) === 'max' ? undefined : breakpoint[key]));
  }, {});
}
// CONCATENATED MODULE: ./src/utils/breakpoints/openBreakpoint/index.ts


// CONCATENATED MODULE: ./src/utils/breakpoints/shouldMergeBreakpoints/shouldMergeBreakpoints.ts
/**
 * Replaces the prefixes in a parameter name.
 * Allows strict comparison of same parameters with different prefixes.
 * Does not test for inclusion/notch.
 *
 * @example
 * neutralizeParamName('maxWidth') // "_width"
 * neutralizeParamName('minWidth') // "_width"
 */
var neutralizeParamName = function neutralizeParamName(paramName) {
  return paramName.replace(/^min|max/, '_');
};
/**
 * Determines whether two given breakpoints can be merged.
 * Assures non-compatible breakpoints are not prompted to
 * be merged during the area params composition.
 */


function shouldCombineBreakpoints(breakpointA, breakpointB) {
  var allParams = Object.keys(breakpointA).concat(Object.keys(breakpointB));
  return allParams.every(function (pristineParamName, index) {
    var paramName = neutralizeParamName(pristineParamName);
    var prevParamName = neutralizeParamName(allParams[index - 1] || paramName);
    return paramName === prevParamName;
  });
}
// CONCATENATED MODULE: ./src/utils/breakpoints/shouldMergeBreakpoints/index.ts


// CONCATENATED MODULE: ./src/utils/breakpoints/getAreaBreakpoints/getAreaBreakpoints.ts
function getAreaBreakpoints_slicedToArray(arr, i) { return getAreaBreakpoints_arrayWithHoles(arr) || getAreaBreakpoints_iterableToArrayLimit(arr, i) || getAreaBreakpoints_nonIterableRest(); }

function getAreaBreakpoints_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function getAreaBreakpoints_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = getAreaBreakpoints_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function getAreaBreakpoints_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function getAreaBreakpoints_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { getAreaBreakpoints_defineProperty(target, key, source[key]); }); } return target; }

function getAreaBreakpoints_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _toArray(arr) { return getAreaBreakpoints_arrayWithHoles(arr) || _iterableToArray(arr) || getAreaBreakpoints_nonIterableRest(); }

function getAreaBreakpoints_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function getAreaBreakpoints_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }









var updateWith = function updateWith(key, updateFunc) {
  return function (args) {
    var _args = _toArray(args),
        first = _args[0],
        rest = _args.slice(1);

    return [updateFunc(args)].concat(_toConsumableArray(rest));
  };
};

var getAreaBreakpoints_createContext = function createContext(areaName) {
  return function (areaBreakpointsList, template, index, templates) {
    var isLastTemplate = index === templates.length - 1;
    var areas = template.areas,
        behavior = template.behavior,
        breakpoint = template.breakpoint;
    var includesArea = areas.includes(areaName);
    var prevAreaBreakpoint = areaBreakpointsList[areaBreakpointsList.length - 1];

    var nextAreaBreakpoint = getAreaBreakpoints_objectSpread({}, breakpoint, {
      behavior: behavior
    });

    var _ref = prevAreaBreakpoint || {
      behavior: ''
    },
        prevBehavior = _ref.behavior,
        prevBreakpoint = getAreaBreakpoints_objectWithoutProperties(_ref, ["behavior"]);

    var shouldMerge = Boolean(prevAreaBreakpoint) && shouldCombineBreakpoints(prevBreakpoint, breakpoint);
    return [nextAreaBreakpoint, prevAreaBreakpoint, includesArea, isLastTemplate, shouldMerge, areaBreakpointsList];
  };
};

var canMergeBreakpoints = function canMergeBreakpoints(_ref2) {
  var _ref3 = getAreaBreakpoints_slicedToArray(_ref2, 5),
      nextAreaBreakpoint = _ref3[0],
      prevAreaBreakpoint = _ref3[1],
      includesArea = _ref3[2],
      isLastTemplate = _ref3[3],
      shouldMerge = _ref3[4];

  return shouldMerge;
};

var shouldOpenBreakpoint = function shouldOpenBreakpoint(_ref4) {
  var _ref5 = getAreaBreakpoints_slicedToArray(_ref4, 4),
      nextAreaBreakpoint = _ref5[0],
      prevAreaBreakpoint = _ref5[1],
      includesArea = _ref5[2],
      isLastTemplate = _ref5[3];

  return isLastTemplate && nextAreaBreakpoint.behavior === 'up';
};

var getAreaBreakpoints_updateBreakpointsList = function updateBreakpointsList(_ref6) {
  var _ref7 = getAreaBreakpoints_slicedToArray(_ref6, 6),
      nextAreaBreakpoint = _ref7[0],
      prevAreaBreakpoint = _ref7[1],
      includesArea = _ref7[2],
      isLastTemplate = _ref7[3],
      shouldMerge = _ref7[4],
      areaBreakpointsList = _ref7[5];

  /* Fallback to an empty object when there is no previous breakpoint in the list */
  var _ref8 = prevAreaBreakpoint || {
    behavior: ''
  },
      prevBehavior = _ref8.behavior;

  var nextBehavior = nextAreaBreakpoint.behavior;
  var wentUp = prevBehavior === 'up';
  var goesDown = nextBehavior === 'down';
  var behavesSame = prevBehavior === nextBehavior;
  var behavesInclusive = wentUp && goesDown;
  /* Alias for better readability */

  var shouldStretch = wentUp;
  var shouldReplaceLastArea = includesArea && (behavesSame || behavesInclusive);

  if (!shouldMerge) {
    shouldReplaceLastArea = false;
  }

  var newBreakpoint = [nextAreaBreakpoint];

  if (!includesArea) {
    /**
     * When the area is stretched, append explicit "null" afterward
     * to prevent the stretched area from being treated as a sibling area
     * in any further calculations.
     */
    newBreakpoint = shouldStretch ? [nextAreaBreakpoint, null] : [null];

    if (shouldStretch) {
      shouldReplaceLastArea = true;
    }
  }

  var targetList = shouldReplaceLastArea ? pop(areaBreakpointsList) : areaBreakpointsList;
  return targetList.concat(newBreakpoint);
};

var getAreaBreakpoints_getAreaBreakpoints = function getAreaBreakpoints(areaName, templates) {
  return templates.reduce(compose(getAreaBreakpoints_updateBreakpointsList, when(shouldOpenBreakpoint, updateWith('nextAreaBreakpoint', spread(openBreakpoint))), when(canMergeBreakpoints, updateWith('nextAreaBreakpoint', spread(mergeBreakpoints))), getAreaBreakpoints_createContext(areaName)), []);
};

/* harmony default export */ var breakpoints_getAreaBreakpoints_getAreaBreakpoints = (getAreaBreakpoints_getAreaBreakpoints);
// CONCATENATED MODULE: ./src/utils/breakpoints/getAreaBreakpoints/index.ts


// CONCATENATED MODULE: ./src/utils/templates/generateComponents/generateComponents.tsx
function generateComponents_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { generateComponents_typeof = function _typeof(obj) { return typeof obj; }; } else { generateComponents_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return generateComponents_typeof(obj); }

function generateComponents_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { generateComponents_defineProperty(target, key, source[key]); }); } return target; }

function generateComponents_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function generateComponents_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = generateComponents_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function generateComponents_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }







/**
 * A high-order component that wraps the given area component in a placeholder.
 * This is used for conditional components, where placeholder component is rendered
 * until the condition for the area component is met (i.e. breakpoint).
 */
var generateComponents_withPlaceholder = function withPlaceholder(Component, breakpoints) {
  var Placeholder = function Placeholder(_ref) {
    var children = _ref.children,
        restProps = generateComponents_objectWithoutProperties(_ref, ["children"]);

    return breakpoints.filter(Boolean).reduce(function (components, breakpointProps, index) {
      var behavior = breakpointProps.behavior,
          queryProps = generateComponents_objectWithoutProperties(breakpointProps, ["behavior"]);

      return components.concat(external_react_["createElement"](components_MediaQuery, _extends({}, queryProps, {
        key: "".concat(Component.displayName, "_").concat(index)
      }), function (matches) {
        return matches && external_react_["createElement"](Component, restProps, children);
      }));
    }, []);
  };

  Placeholder.displayName = "Placeholder(".concat(Component.displayName, ")");
  return Placeholder;
};

var generateComponents_createAreaComponent = function createAreaComponent(areaName) {
  return function (props) {
    return external_react_["createElement"](components_Box, _extends({
      area: areaName
    }, props));
  };
};
/**
 * Returns a map of React components based on the given grid areas
 * in the given template definitions.
 */


function generateComponents(_ref2) {
  var areas = _ref2.areas,
      templates = _ref2.templates;
  var componentsMap = areas.reduce(function (components, areaName) {
    var areaParams = breakpoints_getAreaBreakpoints_getAreaBreakpoints(areaName, templates);
    var shouldAlwaysRender = areaParams.length === 1 && areaParams.every(function (breakpoint) {
      return !breakpoint.minWidth && !breakpoint.maxWidth;
    });
    var Component = generateComponents_createAreaComponent(areaName);
    var capitalizedAreaName = capitalize(areaName);
    Component.displayName = capitalizedAreaName;
    var ResponsiveComponent = shouldAlwaysRender ? Component : generateComponents_withPlaceholder(Component, areaParams);
    return generateComponents_objectSpread({}, components, generateComponents_defineProperty({}, capitalizedAreaName, ResponsiveComponent));
  }, {});
  /**
   * Return plain components map for browsers that don't support Proxy.
   * Requires safety check before rendering conditional areas.
   */

  return typeof Proxy === 'undefined' ? componentsMap : new Proxy(componentsMap, {
    get: function get(components, areaName) {
      if (areaName in components || generateComponents_typeof(areaName) === 'symbol') {
        return components[areaName];
      } // @ts-ignore-line


      if (false) {}
      /**
       * Replace non-existing area component with
       * the dummy component that renders nothing.
       * This prevents from the exception when rendering "undefined"
       * and allows conditional template areas.
       */


      return function () {
        return null;
      };
    }
  });
}
// CONCATENATED MODULE: ./src/utils/templates/generateComponents/index.ts


// CONCATENATED MODULE: ./src/utils/strings/sanitizeTemplateString/sanitizeTemplateString.ts


/**
 * Returns an array of unique normalized grid areas
 * from the given template string.
 */
var sanitizeTemplateString = compose(function (list) {
  return list.sort();
},
/* Deduplicates area strings */
function (list) {
  return Array.from(new Set(list));
},
/* Filters out empty area strings */
function (arr) {
  return arr.filter(Boolean);
},
/* Splits into a list of areas */
function (str) {
  return str.split(' ');
},
/* Deduplicates multiple spaces */
function (str) {
  return str.replace(/\s+/g, ' ');
},
/* Replaces newlines and single quotes with spaces */
function (str) {
  return str.replace(/\r?\n|\'+/g, ' ');
});
/* harmony default export */ var sanitizeTemplateString_sanitizeTemplateString = (sanitizeTemplateString);
// CONCATENATED MODULE: ./src/utils/strings/sanitizeTemplateString/index.ts


// CONCATENATED MODULE: ./src/utils/templates/parseTemplates/filterTemplateProps.ts
function filterTemplateProps_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { filterTemplateProps_defineProperty(target, key, source[key]); }); } return target; }

function filterTemplateProps_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Accepts a props object and filters it to include
 * only template-related prop:value pairs.
 */
var filterTemplateProps_filterTemplateProps = function filterTemplateProps(props) {
  return Object.keys(props).filter(function (propName) {
    var _parsePropName = parsePropName(propName),
        purePropName = _parsePropName.purePropName;

    return ['areas', 'template'].includes(purePropName);
  }).reduce(function (acc, propName) {
    return filterTemplateProps_objectSpread({}, acc, filterTemplateProps_defineProperty({}, propName, sanitizeTemplateString_sanitizeTemplateString(props[propName])));
  }, {});
};

/* harmony default export */ var parseTemplates_filterTemplateProps = (filterTemplateProps_filterTemplateProps);
// CONCATENATED MODULE: ./src/utils/templates/parseTemplates/parseTemplates.ts
function parseTemplates_slicedToArray(arr, i) { return parseTemplates_arrayWithHoles(arr) || parseTemplates_iterableToArrayLimit(arr, i) || parseTemplates_nonIterableRest(); }

function parseTemplates_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function parseTemplates_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function parseTemplates_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }








/**
 * Memoize areas generation based on the sanitized "templateProp:areas" pairs.
 * Alphabetical sorting of incoming template areas allows reproducible cache keys.
 * @todo `pairs` is an empty array sometimes. Should we handle it somehow?
 */
var memoized = memoizeWith(function (templateProps) {
  var pairs = Object.entries(templateProps).reduce(function (acc, _ref) {
    var _ref2 = parseTemplates_slicedToArray(_ref, 2),
        propName = _ref2[0],
        templateAreas = _ref2[1];

    return acc.concat("".concat(propName, ":").concat(templateAreas.join()));
  }, []);
  return hashString(pairs.join()).toString();
});
var parseTemplates = compose(memoized(compose(generateComponents, getAreasList)), parseTemplates_filterTemplateProps);
/* harmony default export */ var parseTemplates_parseTemplates = (parseTemplates);
// CONCATENATED MODULE: ./src/utils/templates/parseTemplates/index.ts


// CONCATENATED MODULE: ./src/components/Composition.tsx
function Composition_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Composition_typeof = function _typeof(obj) { return typeof obj; }; } else { Composition_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Composition_typeof(obj); }

function Composition_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Composition_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Composition_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Composition_templateObject() {
  var data = Composition_taggedTemplateLiteral(["\n  && {\n    ", ";\n    display: ", ";\n  }\n"]);

  Composition_templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function Composition_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }






var CompositionWrapper = external_styled_components_default.a.div(Composition_templateObject(), applyStyles, function (_ref) {
  var inline = _ref.inline;
  return inline ? 'inline-grid' : 'grid';
});

var Composition_Composition = function Composition(_ref2) {
  var children = _ref2.children,
      restProps = Composition_objectWithoutProperties(_ref2, ["children"]);

  var areaComponents = parseTemplates_parseTemplates(restProps);
  var hasAreaComponents = Object.keys(areaComponents).length > 0;

  var childrenType = Composition_typeof(children);

  var hasChildrenFunction = childrenType === 'function'; // Warn on attempt to use "areas"/"template" props without children-as-function.
  // Render in that case still occurs, but it doesn't produce the expected result.

  warn(!(hasAreaComponents && !hasChildrenFunction), "Failed to render 'Composition' with template areas [\"".concat(Object.keys(areaComponents).join('", "'), "\"]: expected children to be a function, but got: ").concat(childrenType, ". Please provide render function as children, or remove assigned template props."));
  return external_react_["createElement"](CompositionWrapper, restProps, hasAreaComponents && hasChildrenFunction ? children(areaComponents) : children);
};

/* harmony default export */ var components_Composition = (Composition_Composition);
// CONCATENATED MODULE: ./src/utils/breakpoints/closeBreakpoint/closeBreakpoint.ts
function closeBreakpoint_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { closeBreakpoint_defineProperty(target, key, source[key]); }); } return target; }

function closeBreakpoint_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function closeBreakpoint_slicedToArray(arr, i) { return closeBreakpoint_arrayWithHoles(arr) || closeBreakpoint_iterableToArrayLimit(arr, i) || closeBreakpoint_nonIterableRest(); }

function closeBreakpoint_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function closeBreakpoint_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function closeBreakpoint_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


/**
 * Accepts a breakpoint and returns a new breakpoint where
 * all the "min" properties of the original breakpoint are
 * flipped into the "max" properties. Any "max" properties
 * of the original breakpoint are omitted.
 *
 * @example
 * flipBreakpoint({ minWidth: 500, maxWidth: 600 })
 * // { maxWidth: 499 }
 */

function flipBreakpoint(breakpoint) {
  return Object.entries(breakpoint).map(function (_ref) {
    var _ref2 = closeBreakpoint_slicedToArray(_ref, 2),
        propName = _ref2[0],
        propValue = _ref2[1];

    return [getPrefix(propName), propName, propValue];
  }).filter(function (_ref3) {
    var _ref4 = closeBreakpoint_slicedToArray(_ref3, 1),
        prefix = _ref4[0];

    return prefix !== 'max';
  }).reduce(function (newBreakpoint, _ref5) {
    var _ref6 = closeBreakpoint_slicedToArray(_ref5, 3),
        prefix = _ref6[0],
        propName = _ref6[1],
        propValue = _ref6[2];

    var hasMinPrefix = prefix === 'min';
    var nextPropName = hasMinPrefix ? propName.replace(/^min/, 'max') : propName;
    /**
     * Subtracts 1 from the edge to not include the area at the beginning
     * of the breakpoint.
     *
     * @todo
     * How is "parseFloat" going to work with non-dimensional options?
     * (i.e. aspectRatio)
     */

    var nextValue = hasMinPrefix ? parseFloat(String(propValue)) - 1 : propValue;
    return closeBreakpoint_objectSpread({}, newBreakpoint, closeBreakpoint_defineProperty({}, nextPropName, nextValue));
  }, {});
}
// CONCATENATED MODULE: ./src/utils/breakpoints/closeBreakpoint/index.ts


// CONCATENATED MODULE: ./src/components/Only.tsx
function Only_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { Only_defineProperty(target, key, source[key]); }); } return target; }

function Only_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Only_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Only_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Only_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var Only_resolveBreakpoint = function resolveBreakpoint(breakpointRef) {
  return typeof breakpointRef === 'string' ? src_Layout.getBreakpoint(breakpointRef) : breakpointRef;
};

var Only_createWrapper = function createWrapper(children, props) {
  return function () {
    for (var _len = arguments.length, breakpoints = new Array(_len), _key = 0; _key < _len; _key++) {
      breakpoints[_key] = arguments[_key];
    }

    var Placeholder = generateComponents_withPlaceholder(components_Box, breakpoints);
    return external_react_["createElement"](Placeholder, props, children);
  };
};

var Only_Only = function Only(_ref) {
  var children = _ref.children,
      except = _ref.except,
      exactBreakpointName = _ref["for"],
      minBreakpointName = _ref.from,
      maxBreakpointName = _ref.to,
      restProps = Only_objectWithoutProperties(_ref, ["children", "except", "for", "from", "to"]);

  var wrapWith = Only_createWrapper(children, restProps);
  /* Render on explicit breakpoint */

  if (exactBreakpointName) {
    return wrapWith(Only_resolveBreakpoint(exactBreakpointName));
  }

  var minBreakpoint = Only_resolveBreakpoint(minBreakpointName);
  var maxBreakpoint = Only_resolveBreakpoint(maxBreakpointName);
  /* Bell, __/--\__ */

  if (minBreakpoint && maxBreakpoint && !except) {
    return wrapWith(mergeBreakpoints(Only_objectSpread({
      behavior: 'down'
    }, maxBreakpoint), Only_objectSpread({
      behavior: 'up'
    }, minBreakpoint), false));
  }
  /* Notch, --\__/-- */


  if (minBreakpoint && maxBreakpoint && except) {
    return wrapWith(flipBreakpoint(minBreakpoint), openBreakpoint(maxBreakpoint));
  }
  /* High-pass, __/-- */


  if (minBreakpoint && !maxBreakpoint) {
    return wrapWith(openBreakpoint(minBreakpoint));
  }
  /* Low-pass, --\__ */


  if (!minBreakpoint && maxBreakpoint) {
    return wrapWith(flipBreakpoint(maxBreakpoint));
  }
  /* Render always when no constrains are provided */


  return children;
};

/* harmony default export */ var components_Only = (Only_Only);
// CONCATENATED MODULE: ./src/utils/functions/debounce/debounce.ts
function debounce(func) {
  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
  var timeout;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var postpone = function postpone() {
      timeout = null;
      return func.apply(void 0, args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(postpone, duration);
  };
}
// CONCATENATED MODULE: ./src/utils/functions/debounce/index.ts

// CONCATENATED MODULE: ./src/hooks/useViewportChange.ts


/**
 * Executes a given callback on debounced window resize.
 */

var useViewportChange_useViewportChange = function useViewportChange(callback, debounceDuration) {
  var handleWindowResize = debounce(callback, debounceDuration);
  Object(external_react_["useEffect"])(function () {
    handleWindowResize();
    window.addEventListener('resize', handleWindowResize);
    return function () {
      return window.removeEventListener('resize', handleWindowResize);
    };
  }, []);
};

/* harmony default export */ var hooks_useViewportChange = (useViewportChange_useViewportChange);
// CONCATENATED MODULE: ./src/hooks/useBreakpointChange.ts




var useBreakpointChange_useBreakpointChange = function useBreakpointChange(callback, debounceDuration) {
  var breakpoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : src_Layout.breakpoints;
  var prevBreakpointName;
  hooks_useViewportChange(function () {
    var nextBreakpointName = Object.keys(breakpoints).find(function (breakpointName) {
      var mediaQuery = createMediaQuery_createMediaQuery(breakpoints[breakpointName], 'only');
      return matchMedia(mediaQuery).matches;
    });

    if (prevBreakpointName !== nextBreakpointName) {
      callback(nextBreakpointName);
      prevBreakpointName = nextBreakpointName;
    }
  });
};

/* harmony default export */ var hooks_useBreakpointChange = (useBreakpointChange_useBreakpointChange);
// CONCATENATED MODULE: ./src/utils/breakpoints/withBreakpoints/withBreakpoints.ts



var withBreakpoints_createWithBreakpoints = function createWithBreakpoints(breakpoints) {
  var existingBreakpoints = Object.keys(breakpoints);
  return function (breakpointsMap, defaultValue) {
    var breakpointMatch = Object.keys(breakpointsMap).filter(function (breakpointName) {
      var hasBreakpoint = existingBreakpoints.includes(breakpointName);

      if (!hasBreakpoint) {
        console.warn('useBreakpoints: Breakpoint "%s" is not found. Add it via "Layout.configure()", or use one of the existing breakpoints (%s).', breakpointName, existingBreakpoints.join(', '));
      }

      return hasBreakpoint;
    }).find(function (breakpointName) {
      var breakpoint = breakpoints[breakpointName];
      var mediaQuery = createMediaQuery_createMediaQuery(breakpoint, 'only');
      return breakpoint && matchMedia(mediaQuery).matches;
    });
    return breakpointMatch ? breakpointsMap[breakpointMatch] : defaultValue;
  };
};

var withBreakpoints = withBreakpoints_createWithBreakpoints(src_Layout.breakpoints);
/* harmony default export */ var withBreakpoints_withBreakpoints = (withBreakpoints);
// CONCATENATED MODULE: ./src/utils/breakpoints/withBreakpoints/index.ts


// CONCATENATED MODULE: ./src/hooks/useResponsiveValue.ts
function useResponsiveValue_slicedToArray(arr, i) { return useResponsiveValue_arrayWithHoles(arr) || useResponsiveValue_iterableToArrayLimit(arr, i) || useResponsiveValue_nonIterableRest(); }

function useResponsiveValue_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function useResponsiveValue_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function useResponsiveValue_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




/**
 * Accepts a map of { breakpointName: value } pairs
 * and returns a value based on the current viewport.
 * Returns default value when no matching pair is found.
 */

var useResponsiveValue_useResponsiveValue = function useResponsiveValue(breakpoints, defaultValue) {
  var _useState = Object(external_react_["useState"])(defaultValue),
      _useState2 = useResponsiveValue_slicedToArray(_useState, 2),
      value = _useState2[0],
      updateValue = _useState2[1];

  hooks_useBreakpointChange(function () {
    var nextValue = withBreakpoints_withBreakpoints(breakpoints, defaultValue);
    updateValue(nextValue);
  });
  return value;
};

/* harmony default export */ var hooks_useResponsiveValue = (useResponsiveValue_useResponsiveValue);
// CONCATENATED MODULE: ./src/hooks/useResponsiveProps.ts
function useResponsiveProps_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { useResponsiveProps_defineProperty(target, key, source[key]); }); } return target; }

function useResponsiveProps_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function useResponsiveProps_slicedToArray(arr, i) { return useResponsiveProps_arrayWithHoles(arr) || useResponsiveProps_iterableToArrayLimit(arr, i) || useResponsiveProps_nonIterableRest(); }

function useResponsiveProps_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function useResponsiveProps_iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function useResponsiveProps_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






/**
 * Accepts an object of responsive props and returns
 * an object of props relative to the current viewport.
 */

var useResponsiveProps_useResponsiveProps = function useResponsiveProps(responsiveProps) {
  var _useState = Object(external_react_["useState"])({}),
      _useState2 = useResponsiveProps_slicedToArray(_useState, 2),
      props = _useState2[0],
      setProps = _useState2[1];

  hooks_useBreakpointChange(function () {
    var relevantProps = Object.keys(responsiveProps).map(parsePropName).filter(function (_ref) {
      var breakpoint = _ref.breakpoint,
          behavior = _ref.behavior;
      var mediaQuery = createMediaQuery_createMediaQuery(src_Layout.breakpoints[breakpoint.name], behavior);
      return matchMedia(mediaQuery).matches;
    }).reduce(function (acc, _ref2) {
      var originPropName = _ref2.originPropName,
          purePropName = _ref2.purePropName;
      return useResponsiveProps_objectSpread({}, acc, useResponsiveProps_defineProperty({}, purePropName, responsiveProps[originPropName]));
    }, {});
    setProps(relevantProps);
  });
  return props;
};

/* harmony default export */ var hooks_useResponsiveProps = (useResponsiveProps_useResponsiveProps);
// CONCATENATED MODULE: ./src/index.ts
/* concated harmony reexport Box */__webpack_require__.d(__webpack_exports__, "Box", function() { return components_Box; });
/* concated harmony reexport Composition */__webpack_require__.d(__webpack_exports__, "Composition", function() { return components_Composition; });
/* concated harmony reexport Only */__webpack_require__.d(__webpack_exports__, "Only", function() { return components_Only; });
/* concated harmony reexport MediaQuery */__webpack_require__.d(__webpack_exports__, "MediaQuery", function() { return components_MediaQuery; });
/* concated harmony reexport useViewportChange */__webpack_require__.d(__webpack_exports__, "useViewportChange", function() { return hooks_useViewportChange; });
/* concated harmony reexport useResponsiveValue */__webpack_require__.d(__webpack_exports__, "useResponsiveValue", function() { return hooks_useResponsiveValue; });
/* concated harmony reexport useBreakpointChange */__webpack_require__.d(__webpack_exports__, "useBreakpointChange", function() { return hooks_useBreakpointChange; });
/* concated harmony reexport useResponsiveProps */__webpack_require__.d(__webpack_exports__, "useResponsiveProps", function() { return hooks_useResponsiveProps; });
/* concated harmony reexport withBreakpoints */__webpack_require__.d(__webpack_exports__, "withBreakpoints", function() { return withBreakpoints_withBreakpoints; });

/* harmony default export */ var src = __webpack_exports__["default"] = (src_Layout);
/* Components */





/* Hooks */





/* Utils */



/***/ })
/******/ ]);
});
//# sourceMappingURL=index.js.map